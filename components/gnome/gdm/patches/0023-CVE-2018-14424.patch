From fb9b340b12cf147eb15a93dc824491fea5bbd3a4 Mon Sep 17 00:00:00 2001
From: Chris Coulson <chris.coulson@canonical.com>
Date: Thu, 19 Jul 2018 18:26:05 +0100
Subject: [PATCH] display-store: Pass the display object rather than the 
id in the removed signal

By the time GdmDisplayStore emits the "display-removed" signal, the display
is no longer in the store and gdm_display_store_lookup will not work in
signal handlers.

Change the "display-removed" parameter from the display id to the GdmDisplay
object, so that signal handers can perform any cleanup they need to do

--- a/daemon/gdm-display-store.c	2018-08-13 11:07:45.010444770 -0700
+++ b/daemon/gdm-display-store.c	2018-08-13 11:10:03.586349955 -0700
@@ -76,15 +76,10 @@
 static void
 stored_display_free (StoredDisplay *stored_display)
 {
-        char *id;
-
-        gdm_display_get_id (stored_display->display, &id, NULL);
-
         g_signal_emit (G_OBJECT (stored_display->store),
                        signals[DISPLAY_REMOVED],
                        0,
-                       id);
-        g_free (id);
+                       stored_display->display);
 
         g_debug ("GdmDisplayStore: Unreffing display: %p",
                  stored_display->display);
@@ -281,9 +276,9 @@
                               G_STRUCT_OFFSET (GdmDisplayStoreClass, display_removed),
                               NULL,
                               NULL,
-                              g_cclosure_marshal_VOID__STRING,
+                              g_cclosure_marshal_VOID__OBJECT,
                               G_TYPE_NONE,
-                              1, G_TYPE_STRING);
+                              1, G_TYPE_OBJECT);
 
         g_type_class_add_private (klass, sizeof (GdmDisplayStorePrivate));
 }
--- a/daemon/gdm-display-store.h	2018-08-13 11:07:51.537070333 -0700
+++ b/daemon/gdm-display-store.h	2018-08-13 11:10:53.600838655 -0700
@@ -49,7 +49,7 @@
         void          (* display_added)    (GdmDisplayStore *display_store,
                                             const char      *id);
         void          (* display_removed)  (GdmDisplayStore *display_store,
-                                            const char      *id);
+                                            GdmDisplay 	*display);
 } GdmDisplayStoreClass;
 
 typedef enum
--- a/daemon/gdm-local-display-factory.c	2018-08-13 11:07:57.447834271 -0700
+++ b/daemon/gdm-local-display-factory.c	2018-08-13 11:11:58.147787221 -0700
@@ -589,18 +589,12 @@
 
 static void
 on_display_removed (GdmDisplayStore        *display_store,
-                    const char             *id,
+                    GdmDisplay             *display,
                     GdmLocalDisplayFactory *factory)
 {
-        GdmDisplay *display;
+        g_signal_handlers_disconnect_by_func (display, G_CALLBACK (on_display_status_changed), factory);
 
-        display = gdm_display_store_lookup (display_store, id);
-
-        if (display != NULL) {
-                g_signal_handlers_disconnect_by_func (display, G_CALLBACK (on_display_status_changed), factory);
-                g_object_weak_unref (G_OBJECT (display), (GWeakNotify)on_display_disposed, factory);
-
-        }
+        g_object_weak_unref (G_OBJECT (display), (GWeakNotify)on_display_disposed, factory);
 }
 
 static gboolean
--- a/daemon/gdm-manager.c	2018-08-13 11:08:03.023878083 -0700
+++ b/daemon/gdm-manager.c	2018-08-13 11:15:56.414401647 -0700
@@ -2116,19 +2116,18 @@
 
 static void
 on_display_removed (GdmDisplayStore *display_store,
-                    const char      *id,
+                    GdmDisplay      *display,
                     GdmManager      *manager)
 {
-        GdmDisplay *display;
+        char    *id;
 
-        display = gdm_display_store_lookup (display_store, id);
-        if (display != NULL) {
-                g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
+	gdm_display_get_id (display, &id, NULL);
+	g_dbus_object_manager_server_unexport (manager->priv->object_manager, id);
+	g_free (id);
 
-                g_signal_handlers_disconnect_by_func (display, G_CALLBACK (on_display_status_changed), manager);
+	g_signal_handlers_disconnect_by_func (display, G_CALLBACK (on_display_status_changed), manager);
 
-                g_signal_emit (manager, signals[DISPLAY_REMOVED], 0, id);
-        }
+	g_signal_emit (manager, signals[DISPLAY_REMOVED], 0, display);
 }
 
 static void
@@ -3189,9 +3188,9 @@
                               G_STRUCT_OFFSET (GdmManagerClass, display_removed),
                               NULL,
                               NULL,
-                              g_cclosure_marshal_VOID__STRING,
+                              g_cclosure_marshal_VOID__OBJECT,
                               G_TYPE_NONE,
-                              1, G_TYPE_STRING);
+                              1, G_TYPE_OBJECT);
 
         g_object_class_install_property (object_class,
                                          PROP_XDMCP_ENABLED,
--- a/daemon/gdm-manager.h	2018-08-13 11:08:08.349572012 -0700
+++ b/daemon/gdm-manager.h	2018-08-13 11:16:40.762117108 -0700
@@ -23,6 +23,7 @@
 #define __GDM_MANAGER_H
 
 #include <glib-object.h>
+#include "gdm-display.h"
 
 #include "gdm-manager-glue.h"
 
@@ -50,7 +51,7 @@
         void          (* display_added)    (GdmManager      *manager,
                                             const char      *id);
         void          (* display_removed)  (GdmManager      *manager,
-                                            const char      *id);
+                                            GdmDisplay      *display);
 } GdmManagerClass;
 
 typedef enum

From dbbe7e37d5e0acca936d07569e4f249c621a2bba Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Thu, 19 Jul 2018 16:01:23 -0400
Subject: [PATCH] display: tie skeleton handlers to object lifetime

Right now we assume a display skeleton object won't
outlive its associated display object.

In theory that should be true, but if we accidentally
leak the skeleton it could erroneously happen.

If that does happen then we'll end accessing free'd
memory, so the leak will turn into a crasher.

This commit addresses this problem by ensuring
the skeleton signal handlers are disconnected when the
associated display object goes away.
--- a/daemon/gdm-display.c	2018-08-13 22:14:13.450717413 -0700
+++ b/daemon/gdm-display.c	2018-08-13 22:15:27.044975342 -0700
@@ -1119,18 +1119,18 @@
         self->priv->object_skeleton = g_dbus_object_skeleton_new (self->priv->id);
         self->priv->display_skeleton = GDM_DBUS_DISPLAY (gdm_dbus_display_skeleton_new ());
 
-        g_signal_connect (self->priv->display_skeleton, "handle-get-id",
-                          G_CALLBACK (handle_get_id), self);
-        g_signal_connect (self->priv->display_skeleton, "handle-get-remote-hostname",
-                          G_CALLBACK (handle_get_remote_hostname), self);
-        g_signal_connect (self->priv->display_skeleton, "handle-get-seat-id",
-                          G_CALLBACK (handle_get_seat_id), self);
-        g_signal_connect (self->priv->display_skeleton, "handle-get-x11-display-name",
-                          G_CALLBACK (handle_get_x11_display_name), self);
-        g_signal_connect (self->priv->display_skeleton, "handle-is-local",
-                          G_CALLBACK (handle_is_local), self);
-        g_signal_connect (self->priv->display_skeleton, "handle-is-initial",
-                          G_CALLBACK (handle_is_initial), self);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-get-id",
+                                 G_CALLBACK (handle_get_id), self, 0);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-get-remote-hostname",
+                                 G_CALLBACK (handle_get_remote_hostname), self, 0);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-get-seat-id",
+                                 G_CALLBACK (handle_get_seat_id), self, 0);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-get-x11-display-name",
+                                 G_CALLBACK (handle_get_x11_display_name), self, 0);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-is-local",
+                                 G_CALLBACK (handle_is_local), self, 0);
+        g_signal_connect_object (self->priv->display_skeleton, "handle-is-initial",
+                                 G_CALLBACK (handle_is_initial), self, 0);
 
         g_dbus_object_skeleton_add_interface (self->priv->object_skeleton,
                                               G_DBUS_INTERFACE_SKELETON (self->priv->display_skeleton));
