#
# Make MIT Kerberos use Solaris RPC and RPCSEC_GSS instead of libgssrpc.
#
# MIT Kerberos bundles the RPC and RPCSEC_GSS implementation with the
# source in separate libgssrpc library. The RPC implementation is based on
# an ancient SUN donated code. It is inferior to the RPC implementation in
# Solaris libc in features and possibly in performance too. Also introducing
# a duplicate implementation would not be wise.
#
# In Solaris, IPv6 is supported only in TI-RPC, older TS-RPC is IPv4 only.
# MIT has patched their TS-RPC for limited IPv6 support.
#
# The patch modifies MIT code to use the standard RPC and RPCSEC_GSS in Solaris.
#
# Specifically:
#    - it modifies the Makefiles not to build libgssrpc and not to link with it
#    - related to above, it strips libgssrpc from krb5-config
#    - moves xdr_alloc.c out of libgssrpc and fixes it for 64-bit
#    - includes correct headers - rpc/rpc.h instead of gssrpc/rpc.h
#    - modifies net-server code to support TI-RPC (transport independent, XTI)
#    - implement kadmin protocol and incr. prop. using Solaris RPCSEC_GSS
#    - reverts MIT modification to iprop, that were needed for RPC differences
#    - makes iprop_port optional again (MIT made it mandatory)
#    - hierarchical incremental propagation tests are removed from t_iprop.py,
#      because the Solaris RPC implementation precludes running this scenario on
#      a single host
#    - server side support for RPCSEC_GSS base changepw protocol
#    - recognize sunw_dbprop_* config options for backward compatibility
#    - defines several functions to locate servers (admin, cpw, kiprop,...)
#    - updates generated dependencies for kadm_host_srv_names.so to build
#    - defines xdr_u_int32 and xdr_int32
#
# This patch is Solaris specific and is not intended for upstream contribution.
# In the future MIT might provide support for system native RPC implementation.
# Patch source: in-house
#
--- a/src/build-tools/krb5-config.in
+++ b/src/build-tools/krb5-config.in
@@ -97,9 +97,6 @@ while test $# != 0; do
 	gssapi)
 	    library=gssapi
 	    ;;
-	gssrpc)
-	    library=gssrpc
-	    ;;
 	kadm-client)
 	    library=kadm_client
 	    ;;
@@ -142,7 +139,6 @@ if test -n "$do_help"; then
     echo "Libraries:"
     echo "        krb5              Kerberos 5 application"
     echo "        gssapi            GSSAPI application with Kerberos 5 bindings"
-    echo "        gssrpc            GSSAPI RPC application"
     echo "        kadm-client       Kadmin client"
     echo "        kadm-server       Kadmin server"
     echo "        kdb               Application that accesses the kerberos database"
@@ -232,17 +228,10 @@ if test -n "$do_libs"; then
 
     if test $library = 'kadm_server'; then
 	lib_flags="$lib_flags -lkadm5srv_mit -lkdb5 $KDB5_DB_LIB"
-	library=gssrpc
     fi
 
     if test $library = 'kadm_client'; then
 	lib_flags="$lib_flags -lkadm5clnt_mit"
-	library=gssrpc
-    fi
-
-    if test $library = 'gssrpc'; then
-	lib_flags="$lib_flags -lgssrpc"
-	library=gssapi
     fi
 
     if test $library = 'gssapi'; then
--- a/src/config/pre.in
+++ b/src/config/pre.in
@@ -321,7 +321,7 @@ KDB5_PLUGIN_LIBS = @KDB5_PLUGIN_LIBS@
 KADMCLNT_DEPLIB	= $(TOPLIBD)/libkadm5clnt_mit$(DEPLIBEXT)
 KADMSRV_DEPLIB	= $(TOPLIBD)/libkadm5srv_mit$(DEPLIBEXT)
 KDB5_DEPLIB	= $(TOPLIBD)/libkdb5$(DEPLIBEXT)
-GSSRPC_DEPLIB	= $(TOPLIBD)/libgssrpc$(DEPLIBEXT)
+GSSRPC_DEPLIB	= # empty
 GSS_DEPLIB	= $(TOPLIBD)/libgssapi_krb5$(DEPLIBEXT)
 KRB5_DEPLIB	= $(TOPLIBD)/libkrb5$(DEPLIBEXT)
 CRYPTO_DEPLIB	= $(TOPLIBD)/libk5crypto$(DEPLIBEXT)
@@ -403,7 +403,7 @@ KRB5_BASE_LIBS	= $(KRB5_LIB) $(K5CRYPTO_LIB) $(COM_ERR_LIB) $(SUPPORT_LIB) $(GEN
 KDB5_LIBS	= $(KDB5_LIB) $(GSSRPC_LIBS)
 GSS_LIBS	= $(GSS_KRB5_LIB)
 # needs fixing if ever used on macOS!
-GSSRPC_LIBS	= -lgssrpc $(GSS_LIBS)
+GSSRPC_LIBS	=  $(GSS_LIBS)
 KADM_COMM_LIBS	= $(GSSRPC_LIBS)
 # need fixing if ever used on macOS!
 KADMSRV_LIBS	= -lkadm5srv_mit $(HESIOD_LIBS) $(KDB5_LIBS) $(KADM_COMM_LIBS)
--- a/src/include/iprop.h
+++ b/src/include/iprop.h
@@ -6,8 +6,7 @@
 #ifndef _IPROP_H_RPCGEN
 #define _IPROP_H_RPCGEN
 
-#include <gssrpc/rpc.h>
-
+#include <rpc/rpc.h>
 
 #ifdef __cplusplus
 extern "C" {
--- a/src/include/k5-int.h
+++ b/src/include/k5-int.h
@@ -220,12 +220,15 @@ typedef unsigned char   u_char;
 #define KRB5_CONF_HTTP_ANCHORS                 "http_anchors"
 #define KRB5_CONF_IGNORE_ACCEPTOR_HOSTNAME     "ignore_acceptor_hostname"
 #define KRB5_CONF_IPROP_ENABLE                 "iprop_enable"
+#define KRB5_CONF_SUNW_DBPROP_ENABLE           "sunw_dbprop_enable"
 #define KRB5_CONF_IPROP_LISTEN                 "iprop_listen"
 #define KRB5_CONF_IPROP_LOGFILE                "iprop_logfile"
 #define KRB5_CONF_IPROP_MASTER_ULOGSIZE        "iprop_master_ulogsize"
+#define KRB5_CONF_SUNW_DBPROP_MASTER_ULOGSIZE  "sunw_dbprop_master_ulogsize"
 #define KRB5_CONF_IPROP_PORT                   "iprop_port"
 #define KRB5_CONF_IPROP_RESYNC_TIMEOUT         "iprop_resync_timeout"
 #define KRB5_CONF_IPROP_SLAVE_POLL             "iprop_slave_poll"
+#define KRB5_CONF_SUNW_DBPROP_SLAVE_POLL       "sunw_dbprop_slave_poll"
 #define KRB5_CONF_K5LOGIN_AUTHORITATIVE        "k5login_authoritative"
 #define KRB5_CONF_K5LOGIN_DIRECTORY            "k5login_directory"
 #define KRB5_CONF_KADMIND_LISTEN               "kadmind_listen"
--- a/src/kadmin/dbutil/dump.c
+++ b/src/kadmin/dbutil/dump.c
@@ -538,7 +538,7 @@ dump_ov_princ(krb5_context context, krb5_db_entry *entry, const char *name,
 
     fputc('\n', fp);
     free(princstr);
-    xdr_free(xdr_osa_princ_ent_rec, &adb);
+    xdr_free(xdr_osa_princ_ent_rec, (char *) &adb);
     return 0;
 }
 
--- a/src/kadmin/dbutil/kadm5_create.c
+++ b/src/kadmin/dbutil/kadm5_create.c
@@ -145,7 +145,7 @@ int kadm5_create_magic_princs(kadm5_config_params *params,
 static int add_admin_princs(void *handle, krb5_context context, char *realm)
 {
     krb5_error_code ret = 0;
-    char *service_name = 0, *kiprop_name = 0, *canonhost = 0;
+    char *service_name = 0, *kiprop_name = 0, *canonhost = 0, *chpw_name = NULL;
     char localname[MAXHOSTNAMELEN];
 
     if (gethostname(localname, MAXHOSTNAMELEN)) {
@@ -163,6 +163,11 @@ static int add_admin_princs(void *handle, krb5_context context, char *realm)
         fprintf(stderr, _("Out of memory\n"));
         goto clean_and_exit;
     }
+    if (asprintf(&chpw_name, "changepw/%s", canonhost) < 0) {
+        ret = ENOMEM;
+        fprintf(stderr, _("Out of memory\n"));
+        goto clean_and_exit;
+    }
     if (asprintf(&kiprop_name, "kiprop/%s", canonhost) < 0) {
         ret = ENOMEM;
         fprintf(stderr, _("Out of memory\n"));
@@ -177,11 +182,21 @@ static int add_admin_princs(void *handle, krb5_context context, char *realm)
         goto clean_and_exit;
 
     if ((ret = add_admin_princ(handle, context,
+                               chpw_name, realm,
+                               KRB5_KDB_DISALLOW_TGT_BASED |
+                               KRB5_KDB_PWCHANGE_SERVICE,
+                               ADMIN_LIFETIME)))
+        goto clean_and_exit;
+
+/* kadmin/admin unusable with Solaris rpcsec_gss */
+#if 0
+    if ((ret = add_admin_princ(handle, context,
                                KADM5_ADMIN_SERVICE, realm,
                                KRB5_KDB_DISALLOW_TGT_BASED |
                                KRB5_KDB_LOCKDOWN_KEYS,
                                ADMIN_LIFETIME)))
         goto clean_and_exit;
+#endif
 
     if ((ret = add_admin_princ(handle, context,
                                KADM5_CHANGEPW_SERVICE, realm,
@@ -197,6 +212,7 @@ clean_and_exit:
     krb5_free_string(context, canonhost);
     free(service_name);
     free(kiprop_name);
+    free(chpw_name);
 
     return ret;
 }
--- a/src/kadmin/server/ipropd_svc.c
+++ b/src/kadmin/server/ipropd_svc.c
@@ -152,6 +152,8 @@ iprop_get_updates_1_svc(kdb_last_t *arg, struct svc_req *rqstp)
     kadm5_server_handle_t handle = global_server_handle;
     char *client_name = 0, *service_name = 0;
     char obuf[256] = {0};
+    gss_name_t name = NULL;
+    OM_uint32 min_stat;
 
     /* default return code */
     ret.ret = UPDATE_ERROR;
@@ -188,6 +190,13 @@ iprop_get_updates_1_svc(kdb_last_t *arg, struct svc_req *rqstp)
     DPRINT("%s: clprinc=`%s'\n\tsvcprinc=`%s'\n", whoami, client_name,
 	   service_name);
 
+    if (!(name = rqst2name(rqstp))) {
+        krb5_klog_syslog(LOG_ERR,
+                         _("%s: Couldn't obtain client's name"),
+                         whoami);
+        goto out;
+    }
+
     if (!iprop_acl_check(handle->context, client_name)) {
 	ret.ret = UPDATE_PERM_DENIED;
 
@@ -233,6 +242,8 @@ out:
 	debprret(whoami, ret.ret, ret.lastentry.last_sno);
     free(client_name);
     free(service_name);
+    if (name)
+        gss_release_name(&min_stat, &name);
     return (&ret);
 }
 
@@ -263,6 +274,18 @@ ipropx_resync(uint32_t vers, struct svc_req *rqstp)
     int pret, fret;
     FILE *p;
     kadm5_server_handle_t handle = global_server_handle;
+    /*
+     * The following two definitions are dead code in upstream krb5.
+     *
+     * OM_uint32 min_stat;
+     * gss_name_t name = NULL;
+     *
+     * They come from initial Sun donation of iprop.
+     * For Solaris specific RPC implementation we need them back.
+     * If upstream removes the dead code, hopefuly placing this comment
+     * in this place will result in an easy-to-debug patch error,
+     * rather then failure to compile.
+     */
     OM_uint32 min_stat;
     gss_name_t name = NULL;
     char *client_name = NULL, *service_name = NULL;
@@ -311,6 +334,13 @@ ipropx_resync(uint32_t vers, struct svc_req *rqstp)
     DPRINT("%s: clprinc=`%s'\n\tsvcprinc=`%s'\n",
 	    whoami, client_name, service_name);
 
+    if (!(name = rqst2name(rqstp))) {
+        krb5_klog_syslog(LOG_ERR,
+                         _("%s: Couldn't obtain client's name"),
+                         whoami);
+        goto out;
+    }
+
     if (!iprop_acl_check(handle->context, client_name)) {
 	ret.ret = UPDATE_PERM_DENIED;
 
@@ -458,6 +488,7 @@ iprop_full_resync_ext_1_svc(uint32_t *argp, struct svc_req *rqstp)
     return ipropx_resync(*argp, rqstp);
 }
 
+#if 0
 static int
 check_iprop_rpcsec_auth(struct svc_req *rqstp)
 {
@@ -530,6 +561,7 @@ fail_name:
      gss_release_name(&min_stat, &name);
      return success;
 }
+#endif
 
 void
 krb5_iprop_prog_1(struct svc_req *rqstp,
@@ -543,6 +575,7 @@ krb5_iprop_prog_1(struct svc_req *rqstp,
     void *(*local)(/* union XXX *, struct svc_req * */);
     char *whoami = "krb5_iprop_prog_1";
 
+#if 0
     if (!check_iprop_rpcsec_auth(rqstp)) {
 	krb5_klog_syslog(LOG_ERR, _("authentication attempt failed: %s, RPC "
 				    "authentication flavor %d"),
@@ -551,6 +584,7 @@ krb5_iprop_prog_1(struct svc_req *rqstp,
 	svcerr_weakauth(transp);
 	return;
     }
+#endif
 
     switch (rqstp->rq_proc) {
     case NULLPROC:
--- a/src/kadmin/server/kadm_rpc_svc.c
+++ b/src/kadmin/server/kadm_rpc_svc.c
@@ -5,7 +5,7 @@
  */
 
 #include <k5-int.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */
 #include <syslog.h>
 #include <kadm5/kadm_rpc.h>
@@ -77,8 +77,7 @@ void kadm_1(rqstp, transp)
      bool_t (*xdr_argument)(), (*xdr_result)();
      bool_t (*local)();
 
-     if (rqstp->rq_cred.oa_flavor != AUTH_GSSAPI &&
-	 !check_rpcsec_auth(rqstp)) {
+     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS) {
 	  krb5_klog_syslog(LOG_ERR, "Authentication attempt failed: %s, "
 			   "RPC authentication flavor %d",
 			   client_addr(rqstp->rq_xprt),
@@ -255,7 +254,7 @@ void kadm_1(rqstp, transp)
 	  return;
      }
      memset(&argument, 0, sizeof(argument));
-     if (!svc_getargs(transp, xdr_argument, &argument)) {
+     if (!svc_getargs(transp, xdr_argument, (char *)&argument)) {
 	  svcerr_decode(transp);
 	  return;
      }
@@ -266,17 +265,19 @@ void kadm_1(rqstp, transp)
 		 "continuing.");
 	  svcerr_systemerr(transp);
      }
-     if (!svc_freeargs(transp, xdr_argument, &argument)) {
+     if (!svc_freeargs(transp, xdr_argument, (char *)&argument)) {
 	  krb5_klog_syslog(LOG_ERR, "WARNING! Unable to free arguments, "
 		 "continuing.");
      }
-     if (!svc_freeargs(transp, xdr_result, &result)) {
+     if (!svc_freeargs(transp, xdr_result, (char *)&result)) {
 	  krb5_klog_syslog(LOG_ERR, "WARNING! Unable to free results, "
 		 "continuing.");
      }
      return;
 }
 
+#if 0
+
 static int
 check_rpcsec_auth(struct svc_req *rqstp)
 {
@@ -368,3 +369,4 @@ gss_to_krb5_name_1(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,
      free(str);
      return success;
 }
+#endif
--- a/src/kadmin/server/ovsec_kadmd.c
+++ b/src/kadmin/server/ovsec_kadmd.c
@@ -45,10 +45,9 @@
 #include <unistd.h>
 #include <netinet/in.h>
 #include <netdb.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi.h>
 #include "gssapiP_krb5.h" /* for kg_get_context */
-#include <gssrpc/auth_gssapi.h>
 #include <kadm5/admin.h>
 #include <kadm5/kadm_rpc.h>
 #include <adm_proto.h>
@@ -56,6 +55,8 @@
 #include <string.h>
 #include "kadm5/server_internal.h" /* XXX for kadm5_server_handle_t */
 #include <kdb_log.h>
+#include <rpc/rpcsec_gss.h>
+#include <kadm5/kadm_rpc.h>
 
 #include "misc.h"
 #include "auth.h"
@@ -350,20 +351,21 @@ main(int argc, char *argv[])
     OM_uint32 minor_status;
     gss_buffer_desc in_buf;
     gss_OID nt_krb5_name_oid = (gss_OID)GSS_KRB5_NT_PRINCIPAL_NAME;
-    auth_gssapi_name names[4];
+    char *names[4];
     kadm5_config_params params;
     verto_ctx *vctx;
     const char *pid_file = NULL;
     char **db_args = NULL, **tmpargs;
     const char *acl_file;
     int ret, i, db_args_size = 0, strong_random = 1, proponly = 0;
+    char **tmp_srv_names;
+    krb5_principal princ;
+    char *pos;
 
     setlocale(LC_ALL, "");
     setvbuf(stderr, NULL, _IONBF, 0);
 
-    names[0].name = names[1].name = names[2].name = names[3].name = NULL;
-    names[0].type = names[1].type = names[2].type = names[3].type =
-        nt_krb5_name_oid;
+    names[0] = names[1] = names[2] = names[3] = NULL;
 
     progname = (strrchr(argv[0], '/') != NULL) ? strrchr(argv[0], '/') + 1 :
         argv[0];
@@ -472,28 +474,88 @@ main(int argc, char *argv[])
     if (!(params.mask & KADM5_CONFIG_ACL_FILE))
         fail_to_start(0, _("Missing required ACL file configuration"));
 
-    ret = setup_loop(proponly, &vctx);
+    ret = kadm5_get_adm_host_srv_names(context, params.realm, &tmp_srv_names);
     if (ret)
-        fail_to_start(ret, _("initializing network"));
+        fail_to_start(ret, _("building GSSAPI auth names"));
+    names[0] = strdup(tmp_srv_names[0]);
+    if (names[0] == NULL)
+        fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+    free_srv_names(tmp_srv_names);
+    tmp_srv_names = NULL;
 
-    names[0].name = build_princ_name(KADM5_ADMIN_SERVICE, params.realm);
-    names[1].name = build_princ_name(KADM5_CHANGEPW_SERVICE, params.realm);
-    if (names[0].name == NULL || names[1].name == NULL)
-        fail_to_start(0, _("Cannot build GSSAPI auth names"));
+    ret = kadm5_get_cpw_host_srv_names(context, params.realm, &tmp_srv_names);
+    if (ret)
+        fail_to_start(ret, _("building GSSAPI auth names"));
+    names[1] = strdup(tmp_srv_names[0]);
+    if (names[1] == NULL)
+        fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+    free_srv_names(tmp_srv_names);
+    tmp_srv_names = NULL;
+
+    if (params.iprop_enabled == TRUE) {
+        ret = kadm5_get_kiprop_host_srv_names(context, params.realm,
+                                              &tmp_srv_names);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        names[2] = strdup(tmp_srv_names[0]);
+        if (names[2] == NULL)
+            fail_to_start(ENOMEM, _("copying GSSAPI auth names"));
+        free_srv_names(tmp_srv_names);
+        tmp_srv_names = NULL;
+
+        /*
+         * For hierarchical incremental propagation we need kadmind
+         * on slave KDCs to register local hostbased kiprop service principal,
+         * not the one for admin server. For least surprise on upgrade we
+         * register both.
+         */
+        ret = krb5_sname_to_principal(context, NULL, KADM5_KIPROP_HOST_SERVICE,
+                                      KRB5_NT_SRV_HST, &princ);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        ret = krb5_unparse_name(context, princ, &names[3]);
+        if (ret)
+            fail_to_start(ret, _("building GSSAPI auth names"));
+        if ((pos = strchr(names[3], '@')) != NULL)
+            *pos = '\0';
+        if ((pos = strchr(names[3], '/')) != NULL)
+            *pos = '@';
+    }
 
     ret = setup_kdb_keytab();
     if (ret)
         fail_to_start(0, _("Cannot set up KDB keytab"));
-
+#if 0
     if (svcauth_gssapi_set_names(names, 2) == FALSE)
         fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+#endif
+    if (!rpc_gss_set_svc_name(names[0], "kerberos_v5", 0, KADM, KADMVERS))
+        fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+    if (!rpc_gss_set_svc_name(names[1], "kerberos_v5", 0, KADM, KADMVERS))
+        fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+    if (params.iprop_enabled == TRUE) {
+        if (!rpc_gss_set_svc_name(names[2], "kerberos_v5", 0,
+                                  KRB5_IPROP_PROG, KRB5_IPROP_VERS))
+            fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+        if (strcmp(names[2], names[3])){
+            if (!rpc_gss_set_svc_name(names[3], "kerberos_v5", 0,
+                                      KRB5_IPROP_PROG, KRB5_IPROP_VERS))
+                fail_to_start(0, _("Cannot set GSSAPI authentication names"));
+
+        }
+    }
 
     /* if set_names succeeded, this will too */
-    in_buf.value = names[1].name;
-    in_buf.length = strlen(names[1].name) + 1;
+    in_buf.value = names[1];
+    in_buf.length = strlen(names[1]);
     (void)gss_import_name(&minor_status, &in_buf, nt_krb5_name_oid,
                           &gss_changepw_name);
 
+    ret = setup_loop(proponly, &vctx);
+    if (ret)
+        fail_to_start(ret, _("initializing network"));
+
+#if 0
     svcauth_gssapi_set_log_badauth2_func(log_badauth, NULL);
     svcauth_gssapi_set_log_badverf_func(log_badverf, NULL);
     svcauth_gssapi_set_log_miscerr_func(log_miscerr, NULL);
@@ -504,6 +566,7 @@ main(int argc, char *argv[])
 
     if (svcauth_gss_set_svc_name(GSS_C_NO_NAME) != TRUE)
         fail_to_start(0, _("Cannot initialize GSSAPI service name"));
+#endif
 
     acl_file = (*params.acl_file != '\0') ? params.acl_file : NULL;
     ret = auth_init(context, acl_file);
@@ -548,14 +611,16 @@ main(int argc, char *argv[])
     krb5_klog_syslog(LOG_INFO, _("finished, exiting"));
 
     /* Clean up memory, etc */
+#if 0
     svcauth_gssapi_unset_names();
+#endif
     kadm5_destroy(global_server_handle);
     loop_free(vctx);
     auth_fini(context);
     (void)gss_release_name(&minor_status, &gss_changepw_name);
     (void)gss_release_name(&minor_status, &gss_oldchangepw_name);
     for (i = 0; i < 4; i++)
-        free(names[i].name);
+        free(names[i]);
 
     krb5_klog_close(context);
     krb5_free_context(context);
--- a/src/kadmin/server/server_stubs.c
+++ b/src/kadmin/server/server_stubs.c
@@ -14,6 +14,8 @@
 #include <kadm5/server_internal.h>
 #include <syslog.h>
 #include <adm_proto.h>  /* krb5_klog_syslog */
+#include <rpc/rpcsec_gss.h>
+#include <rpc/svc_mt.h>
 #include "misc.h"
 #include "auth.h"
 
@@ -21,19 +23,24 @@ extern gss_name_t                       gss_changepw_name;
 extern gss_name_t                       gss_oldchangepw_name;
 extern void *                           global_server_handle;
 
-#define CHANGEPW_SERVICE(rqstp)                                         \
-    (cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred), gss_changepw_name) | \
-     (gss_oldchangepw_name &&                                           \
-      cmp_gss_names_rel_1(acceptor_name(rqstp->rq_svccred),             \
+#define CHANGEPW_SERVICE(rqstp)                                     \
+    (cmp_gss_names_rel_1(acceptor_name(rqstp), gss_changepw_name) | \
+     (gss_oldchangepw_name &&                                       \
+      cmp_gss_names_rel_1(acceptor_name(rqstp),                     \
                           gss_oldchangepw_name)))
 
+/*
+ * Non-public function from rpc/libc found on Solaris. We (mis)use it to fetch
+ * gss_ctx_id_t established earlier. See ticket_is_initial() for more details.
+ */
+extern SVCAUTH *__svc_get_svcauth(SVCXPRT *);
 
 static int gss_to_krb5_name(kadm5_server_handle_t handle,
                             gss_name_t gss_name, krb5_principal *princ);
 
 static int gss_name_to_string(gss_name_t gss_name, gss_buffer_desc *str);
 
-static gss_name_t acceptor_name(gss_ctx_id_t context);
+static gss_name_t acceptor_name(struct svc_req *rqstp);
 
 gss_name_t rqst2name(struct svc_req *rqstp);
 
@@ -107,6 +114,8 @@ static kadm5_ret_t new_server_handle(krb5_ui_4 api_version,
                                      *out_handle)
 {
     kadm5_server_handle_t handle;
+    gss_name_t name = NULL;
+    OM_uint32 min_stat;
 
     *out_handle = NULL;
 
@@ -117,13 +126,18 @@ static kadm5_ret_t new_server_handle(krb5_ui_4 api_version,
     *handle = *(kadm5_server_handle_t)global_server_handle;
     handle->api_version = api_version;
 
-    if (! gss_to_krb5_name(handle, rqst2name(rqstp),
-                           &handle->current_caller)) {
+    if (!(name = rqst2name(rqstp))) {
         free(handle);
         return KADM5_FAILURE;
     }
+    if (! gss_to_krb5_name(handle, name, &handle->current_caller)) {
+        free(handle);
+        gss_release_name(&min_stat, &name);
+        return KADM5_FAILURE;
+    }
 
     *out_handle = handle;
+    gss_release_name(&min_stat, &name);
     return 0;
 }
 
@@ -182,38 +196,54 @@ int setup_gss_names(struct svc_req *rqstp,
                     gss_buffer_desc *client_name,
                     gss_buffer_desc *server_name)
 {
-    OM_uint32 maj_stat, min_stat;
-    gss_name_t server_gss_name;
+    OM_uint32 min_stat;
+    gss_name_t name = NULL;
+    rpc_gss_rawcred_t *raw_cred;
 
-    if (gss_name_to_string(rqst2name(rqstp), client_name) != 0)
-        return -1;
-    maj_stat = gss_inquire_context(&min_stat, rqstp->rq_svccred, NULL,
-                                   &server_gss_name, NULL, NULL, NULL,
-                                   NULL, NULL);
-    if (maj_stat != GSS_S_COMPLETE) {
-        gss_release_buffer(&min_stat, client_name);
-        gss_release_name(&min_stat, &server_gss_name);
+    if (!(name = rqst2name(rqstp))) {
         return -1;
     }
-    if (gss_name_to_string(server_gss_name, server_name) != 0) {
-        gss_release_buffer(&min_stat, client_name);
-        gss_release_name(&min_stat, &server_gss_name);
+    if (gss_name_to_string(name, client_name) != 0) {
+        gss_release_name(&min_stat, &name);
         return -1;
     }
-    gss_release_name(&min_stat, &server_gss_name);
+    gss_release_name(&min_stat, &name);
+
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    server_name->value = strdup(raw_cred->svc_principal);
+    if (server_name->value == NULL) {
+        gss_release_buffer(&min_stat, client_name);
+        return -1;
+    }
+    server_name->length = strlen(raw_cred->svc_principal);
+
     return 0;
 }
 
-static gss_name_t acceptor_name(gss_ctx_id_t context)
+static gss_name_t acceptor_name(struct svc_req *rqstp)
 {
     OM_uint32 maj_stat, min_stat;
-    gss_name_t name;
+    gss_name_t name = NULL;
+    rpc_gss_rawcred_t *raw_cred;
+    gss_buffer_desc name_buff;
 
-    maj_stat = gss_inquire_context(&min_stat, context, NULL, &name,
-                                   NULL, NULL, NULL, NULL, NULL);
-    if (maj_stat != GSS_S_COMPLETE)
-        return NULL;
-    return name;
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    name_buff.value = raw_cred->svc_principal;
+    name_buff.length = strlen(raw_cred->svc_principal);
+    maj_stat = gss_import_name(&min_stat, &name_buff,
+        (gss_OID) gss_nt_krb5_name, &name);
+    if (maj_stat != GSS_S_COMPLETE) {
+        gss_release_buffer(&min_stat, &name_buff);
+        return (NULL);
+    }
+    maj_stat = gss_display_name(&min_stat, name, &name_buff, NULL);
+    if (maj_stat != GSS_S_COMPLETE) {
+        gss_release_buffer(&min_stat, &name_buff);
+      return (NULL);
+    }
+    gss_release_buffer(&min_stat, &name_buff);
+
+     return name;
 }
 
 static int gss_to_krb5_name(kadm5_server_handle_t handle,
@@ -267,7 +297,7 @@ static kadm5_ret_t
 stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
            kadm5_server_handle_t *handle_out, krb5_ui_4 *api_version_out,
            gss_buffer_t client_name_out, gss_buffer_t service_name_out,
-           char **princ_str_out)
+           char **princ_str_out, gss_name_t *name_out)
 {
     kadm5_ret_t ret;
 
@@ -290,6 +320,11 @@ stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
         if (krb5_unparse_name((*handle_out)->context, princ, princ_str_out))
             return KADM5_BAD_PRINCIPAL;
     }
+    if (name_out !=  NULL) { 
+        *name_out = rqst2name(rqstp);
+        if (*name_out == NULL)	
+		return KADM5_FAILURE;
+    }
 
     return KADM5_OK;
 }
@@ -297,7 +332,8 @@ stub_setup(krb5_ui_4 api_version, struct svc_req *rqstp, krb5_principal princ,
 /* Perform common cleanup for server stub functions. */
 static void
 stub_cleanup(kadm5_server_handle_t handle, char *princ_str,
-             gss_buffer_t client_name, gss_buffer_t service_name)
+             gss_buffer_t client_name, gss_buffer_t service_name,
+	     gss_name_t name)
 {
     OM_uint32 minor_stat;
 
@@ -306,6 +342,8 @@ stub_cleanup(kadm5_server_handle_t handle, char *princ_str,
     free(princ_str);
     gss_release_buffer(&minor_stat, client_name);
     gss_release_buffer(&minor_stat, service_name);
+    if (name)
+        gss_release_name(&minor_stat, &name);
 }
 
 static krb5_boolean
@@ -343,15 +381,64 @@ changepw_not_self(kadm5_server_handle_t handle, struct svc_req *rqstp,
                                 princ);
 }
 
+/*
+ * There is a small difference between Solaris and upstream MIT kerberos here.
+ * The devil hides in definition of svc_req structure, which looks on Solaris
+ * as follows:
+ * 	struct svc_req {
+ *		rpcprog_t	rq_prog;
+ *		rpcvers_t	rq_vers;
+ *		rpcproc_t	rq_proc;
+ *		struct opaque_auth rq_cred;
+ *		caddr_t		rq_clntcred;
+ *		SVCXPRT		*rq_xprt;
+ *		bslabel_t	*rq_label;
+ * 	};
+ *
+ * The same structure defined by native kerberos RPC:
+ *	struct svc_req {
+ *		rpcprog_t		rq_prog;
+ *		rpcvers_t		rq_vers;
+ *		rpcproc_t		rq_proc;
+ *		struct opaque_auth rq_cred;
+ *		void *		rq_clntcred;
+ *		void *		rq_svccred;
+ *		void *		rq_clntname;
+ *		SVCXPRT		*rq_xprt;
+ *		...
+ *	};
+ *
+ * They are almost same. The deal breaker here is rq_svccred member found in
+ * upstream. Upstream uses rq_svccred to convey GSS context id between parties.
+ *
+ * On Solaris the GSS context ID hides beneath RPC API surface in GSS params
+ * attached to SVCAUTH (Authenticator). In order to reach it we deliberately
+ * ask non public __svc_get_svcauth() to do it for us.
+ */
 static krb5_boolean
 ticket_is_initial(struct svc_req *rqstp)
 {
     OM_uint32 status, minor_stat;
-    krb5_flags flags;
+    krb5_flags flags = 0;
+    rpc_gss_rawcred_t *gss_rcred;
+    rpc_gss_error_t gss_error;
+    gss_ctx_id_t context_handle;
+    SVCAUTH *auth;
 
-    status = gss_krb5_get_tkt_flags(&minor_stat, rqstp->rq_svccred, &flags);
+    if (!rpc_gss_getcred(rqstp, &gss_rcred, NULL, NULL)) {
+	rpc_gss_get_error(&gss_error);
+	return 0;
+    }
+
+    auth = __svc_get_svcauth(rqstp->rq_xprt);
+    if (auth == NULL)
+	return 0;
+
+    context_handle = auth->svc_gss_parms.context;
+    status = gss_krb5_get_tkt_flags(&minor_stat, context_handle, &flags);
     if (status != GSS_S_COMPLETE)
-        return 0;
+	    return 0;
+
     return (flags & TKT_FLG_INITIAL) != 0;
 }
 
@@ -439,10 +526,11 @@ create_principal_2_svc(cprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -466,7 +554,7 @@ create_principal_2_svc(cprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -479,10 +567,11 @@ create_principal3_2_svc(cprinc3_arg *arg, generic_ret *ret,
     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -506,7 +595,7 @@ create_principal3_2_svc(cprinc3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -534,10 +623,11 @@ delete_principal_2_svc(dprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -570,7 +660,7 @@ delete_principal_2_svc(dprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -583,10 +673,11 @@ modify_principal_2_svc(mprinc_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->rec.principal,
                            &handle, &ret->api_version, &client_name,
-                           &service_name, &prime_arg);
+                           &service_name, &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -618,7 +709,7 @@ modify_principal_2_svc(mprinc_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -633,10 +724,11 @@ rename_principal_2_svc(rprinc_arg *arg, generic_ret *ret,
     const char                  *errmsg = NULL;
     size_t                      tlen1, tlen2, clen, slen;
     char                        *tdots1, *tdots2, *cdots, *sdots;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -702,7 +794,7 @@ rename_principal_2_svc(rprinc_arg *arg, generic_ret *ret,
 exit_func:
     free(prime_arg1);
     free(prime_arg2);
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -714,10 +806,11 @@ get_principal_2_svc(gprinc_arg *arg, gprinc_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -743,7 +836,7 @@ get_principal_2_svc(gprinc_arg *arg, gprinc_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -755,10 +848,11 @@ get_princs_2_svc(gprincs_arg *arg, gprincs_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -786,7 +880,7 @@ get_princs_2_svc(gprincs_arg *arg, gprincs_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -799,10 +893,11 @@ chpass_principal_2_svc(chpass_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -836,7 +931,7 @@ chpass_principal_2_svc(chpass_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -849,10 +944,11 @@ chpass_principal3_2_svc(chpass3_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -889,7 +985,7 @@ chpass_principal3_2_svc(chpass3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -902,10 +998,11 @@ setv4key_principal_2_svc(setv4key_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -938,7 +1035,7 @@ setv4key_principal_2_svc(setv4key_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -952,10 +1049,11 @@ setkey_principal_2_svc(setkey_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -988,7 +1086,7 @@ setkey_principal_2_svc(setkey_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1001,10 +1099,11 @@ setkey_principal3_2_svc(setkey3_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1038,7 +1137,7 @@ setkey_principal3_2_svc(setkey3_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1051,10 +1150,11 @@ setkey_principal4_2_svc(setkey4_arg *arg, generic_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1087,7 +1187,7 @@ setkey_principal4_2_svc(setkey4_arg *arg, generic_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1122,10 +1222,11 @@ chrand_principal_2_svc(chrand_arg *arg, chrand_ret *ret, struct svc_req *rqstp)
     int                         nkeys;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1164,7 +1265,7 @@ chrand_principal_2_svc(chrand_arg *arg, chrand_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1179,10 +1280,11 @@ chrand_principal3_2_svc(chrand3_arg *arg, chrand_ret *ret,
     int                         nkeys;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1223,7 +1325,7 @@ chrand_principal3_2_svc(chrand3_arg *arg, chrand_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1235,10 +1337,11 @@ create_policy_2_svc(cpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1265,7 +1368,7 @@ create_policy_2_svc(cpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1277,10 +1380,11 @@ delete_policy_2_svc(dpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1305,7 +1409,7 @@ delete_policy_2_svc(dpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1317,10 +1421,11 @@ modify_policy_2_svc(mpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1346,7 +1451,7 @@ modify_policy_2_svc(mpol_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1360,12 +1465,13 @@ get_policy_2_svc(gpol_arg *arg, gpol_ret *ret, struct svc_req *rqstp)
     kadm5_principal_ent_rec     caller_ent;
     kadm5_server_handle_t       handle;
     const char                  *errmsg = NULL, *cpolicy = NULL;
+    gss_name_t                  name = NULL;
 
     memset(&caller_ent, 0, sizeof(caller_ent));
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1399,7 +1505,7 @@ get_policy_2_svc(gpol_arg *arg, gpol_ret *ret, struct svc_req *rqstp)
 
 exit_func:
     (void)kadm5_free_principal_ent(handle->lhandle, &caller_ent);
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1411,10 +1517,11 @@ get_pols_2_svc(gpols_arg *arg, gpols_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, NULL, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           NULL);
+                           NULL, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1441,7 +1548,7 @@ get_pols_2_svc(gpols_arg *arg, gpols_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1454,7 +1561,7 @@ get_privs_2_svc(krb5_ui_4 *arg, getprivs_ret *ret, struct svc_req *rqstp)
     const char                     *errmsg = NULL;
 
     ret->code = stub_setup(*arg, rqstp, NULL, &handle, &ret->api_version,
-                           &client_name, &service_name, NULL);
+                           &client_name, &service_name, NULL, NULL);
     if (ret->code)
         goto exit_func;
 
@@ -1469,7 +1576,7 @@ get_privs_2_svc(krb5_ui_4 *arg, getprivs_ret *ret, struct svc_req *rqstp)
         krb5_free_error_message(handle->context, errmsg);
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, NULL);
     return TRUE;
 }
 
@@ -1482,10 +1589,11 @@ purgekeys_2_svc(purgekeys_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     kadm5_server_handle_t       handle;
 
     const char                  *errmsg = NULL;
+    gss_name_t                  name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1508,7 +1616,7 @@ purgekeys_2_svc(purgekeys_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1520,10 +1628,11 @@ get_strings_2_svc(gstrings_arg *arg, gstrings_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1546,7 +1655,7 @@ get_strings_2_svc(gstrings_arg *arg, gstrings_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1558,10 +1667,11 @@ set_string_2_svc(sstring_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1584,7 +1694,7 @@ set_string_2_svc(sstring_arg *arg, generic_ret *ret, struct svc_req *rqstp)
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
 
@@ -1599,7 +1709,7 @@ init_2_svc(krb5_ui_4 *arg, generic_ret *ret, struct svc_req *rqstp)
     char *cdots, *sdots;
 
     ret->code = stub_setup(*arg, rqstp, NULL, &handle, &ret->api_version,
-                           &client_name, &service_name, NULL);
+                           &client_name, &service_name, NULL, NULL);
     if (ret->code)
         goto exit_func;
 
@@ -1625,18 +1735,27 @@ init_2_svc(krb5_ui_4 *arg, generic_ret *ret, struct svc_req *rqstp)
         krb5_free_error_message(handle->context, errmsg);
 
 exit_func:
-    stub_cleanup(handle, NULL, &client_name, &service_name);
+    stub_cleanup(handle, NULL, &client_name, &service_name, NULL);
     return TRUE;
 }
 
 gss_name_t
 rqst2name(struct svc_req *rqstp)
 {
+    OM_uint32 maj_stat, min_stat;
+    gss_name_t name;
+    rpc_gss_rawcred_t * raw_cred;
+    gss_buffer_desc name_buff;
 
-    if (rqstp->rq_cred.oa_flavor == RPCSEC_GSS)
-        return rqstp->rq_clntname;
-    else
-        return rqstp->rq_clntcred;
+    rpc_gss_getcred(rqstp, &raw_cred, NULL, NULL);
+    name_buff.value = raw_cred->client_principal->name;
+    name_buff.length = raw_cred->client_principal->len;
+    maj_stat = gss_import_name(&min_stat, &name_buff,
+                               (gss_OID) GSS_C_NT_EXPORT_NAME, &name);
+    if (maj_stat != GSS_S_COMPLETE) {
+        return (NULL);
+    }
+    return (name);
 }
 
 bool_t
@@ -1648,10 +1767,11 @@ get_principal_keys_2_svc(getpkeys_arg *arg, getpkeys_ret *ret,
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
     kadm5_server_handle_t           handle;
     const char                      *errmsg = NULL;
+    gss_name_t                      name = NULL;
 
     ret->code = stub_setup(arg->api_version, rqstp, arg->princ, &handle,
                            &ret->api_version, &client_name, &service_name,
-                           &prime_arg);
+                           &prime_arg, &name);
     if (ret->code)
         goto exit_func;
 
@@ -1692,6 +1812,6 @@ get_principal_keys_2_svc(getpkeys_arg *arg, getpkeys_ret *ret,
     }
 
 exit_func:
-    stub_cleanup(handle, prime_arg, &client_name, &service_name);
+    stub_cleanup(handle, prime_arg, &client_name, &service_name, name);
     return TRUE;
 }
--- a/src/lib/Makefile.in
+++ b/src/lib/Makefile.in
@@ -1,5 +1,5 @@
 mydir=lib
-SUBDIRS=crypto krb5 gssapi rpc kdb kadm5 apputils krad
+SUBDIRS=crypto krb5 gssapi kdb kadm5 apputils krad
 WINSUBDIRS=crypto krb5 gssapi
 BUILDTOP=$(REL)..
 
--- a/src/lib/apputils/net-server.c
+++ b/src/lib/apputils/net-server.c
@@ -33,7 +33,7 @@
 #include "port-sockets.h"
 #include "socket-utils.h"
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 
 #ifdef HAVE_NETINET_IN_H
 #include <sys/types.h>
@@ -185,6 +185,9 @@ struct connection {
 #define FREE_SET_DATA(set)                                      \
     (free(set.data), set.data = 0, set.max = 0, set.n = 0)
 
+#define EMPTY(set)                                              \
+    (set.n == 0)
+
 /*
  * N.B.: The Emacs cc-mode indentation code seems to get confused if
  * the macro argument here is one word only.  So use "unsigned short"
@@ -572,6 +575,113 @@ static void process_tcp_connection_write(verto_ctx *ctx, verto_ev *ev);
 static void accept_rpc_connection(verto_ctx *ctx, verto_ev *ev);
 static void process_rpc_connection(verto_ctx *ctx, verto_ev *ev);
 
+static int
+set_tli_opt(int fd, int level, int name, const void *val, unsigned int val_len)
+{
+    struct t_optmgmt req, rep;
+    struct opthdr *opt;
+    char reqbuf[256];
+
+    if (val_len + sizeof (struct opthdr) > sizeof (reqbuf))
+        return -1;
+
+    opt = (struct opthdr *) reqbuf;
+    opt->level = level;
+    opt->name = name;
+    opt->len = val_len;
+
+    memcpy(reqbuf + sizeof (struct opthdr), val, val_len);
+
+    req.flags = T_NEGOTIATE;
+    req.opt.len = sizeof (struct opthdr) + opt->len;
+    req.opt.buf = (char *) opt;
+
+    rep.flags = 0;
+    rep.opt.buf = reqbuf;
+    rep.opt.maxlen = sizeof (reqbuf);
+
+    if (t_optmgmt(fd, &req, &rep) < 0 || rep.flags != T_SUCCESS) {
+        t_error("t_optmgmt");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Create a tli/xti endpoint and bind it to addr. Ensure the file descriptor
+ * will work with select. Set cloexec, reuseaddr, and if applicable v6-only.
+ * Does not call listen().  Returns -1 on failure after logging an error.
+ */
+static int
+create_server_endpoint(struct netconfig *nconf, struct sockaddr *sock_address,
+		       const char *prog, int *err)
+{
+    int fd, on;
+    struct t_info tinfo;
+    struct t_bind *tbind;
+
+    /* open transport endpoint */
+    fd = t_open(nconf->nc_device, O_RDWR, &tinfo);
+    if (fd == -1) {
+        *err = errno;
+        com_err(prog, errno, _("unable to open connection for ADMIN server"));
+        return -1;
+    }
+    set_cloexec_fd(fd);
+
+    /* ensure fd works with select */
+    if (fd >= FD_SETSIZE) {
+	*err = errno;
+        t_close(fd);
+        com_err(prog, 0, _("endpoint fd number %d too high"), fd);
+        return -1;
+    }
+
+    /* set SO_REUSEADDR */
+    on = 1;
+    if (set_tli_opt(fd, SOL_SOCKET, SO_REUSEADDR , &on, sizeof (on)) < 0)
+        com_err(prog, errno,
+                _("cannot enable SO_REUSEADDR on fd %d"), fd);
+
+    /* set IPv6-only as appropriate */
+    if (sock_address->sa_family == AF_INET6) {
+#ifdef IPV6_V6ONLY
+        if (set_tli_opt(fd, IPPROTO_IPV6, IPV6_V6ONLY , &on, sizeof (on)) < 0)
+            com_err(prog, errno, _("cannot set IPV6_V6ONLY on fd %d"), fd);
+#else
+        krb5_klog_syslog(LOG_INFO, _("no IPV6_V6ONLY socket option support"));
+#endif /* IPV6_V6ONLY */
+    }
+
+    /* bind fd to specified address */
+    tbind = (struct t_bind *)t_alloc(fd, T_BIND, T_ADDR);
+    if (tbind == NULL) {
+	*err = ENOMEM;
+	com_err(prog, errno, _("Cannot allocate t_bind structure."));
+        t_close(fd);
+        return -1;
+    }
+
+    tbind->qlen = 64;    /* Chosen Arbitrarily, from svc_generic.c */
+    tbind->addr.len = (sock_address->sa_family == AF_INET6) ?
+                      sizeof (struct sockaddr_in6) :
+                      sizeof (struct sockaddr_in);
+    memcpy(tbind->addr.buf, sock_address, tbind->addr.len);
+
+    if (t_bind(fd, tbind, NULL) < 0) {
+	*err = errno;
+        com_err(prog, errno, _("Cannot bind transport endpoint to %s"),
+                paddr(sock_address));
+        t_free(tbind, T_BIND);
+        t_close(fd);
+        return -1;
+    }
+    t_free(tbind, T_BIND);
+
+    return fd;
+}
+
 /*
  * Create a socket and bind it to addr.  Ensure the socket will work with
  * select().  Set the socket cloexec, reuseaddr, and if applicable v6-only.
@@ -685,18 +795,37 @@ setup_socket(struct bind_address *ba, struct sockaddr *sock_address,
              void *handle, const char *prog, verto_ctx *ctx,
              int tcp_listen_backlog, verto_callback vcb, enum conn_type ctype)
 {
-    krb5_error_code ret;
+    krb5_error_code ret = 0;
     struct connection *conn;
     verto_ev_flag flags;
     verto_ev *ev = NULL;
     int sock = -1;
+    struct netconfig *nconf = NULL;
+    int err;
 
     krb5_klog_syslog(LOG_DEBUG, _("Setting up %s socket for address %s"),
                      bind_type_names[ba->type], paddr(sock_address));
 
     /* Create the socket. */
-    ret = create_server_socket(sock_address, bind_socktypes[ba->type], prog,
-                               &sock);
+    if (ba->type == RPC) {
+        switch (sock_address->sa_family) {
+        case AF_INET:
+            nconf = getnetconfigent("tcp");
+            break;
+        case AF_INET6:
+            nconf = getnetconfigent("tcp6");
+            break;
+        default:
+            ret = EAFNOSUPPORT;
+            goto cleanup;
+        }
+        sock = create_server_endpoint(nconf, sock_address, prog, &err);
+	if (sock == -1)
+	    ret = err;
+    } else {
+	ret = create_server_socket(sock_address, bind_socktypes[ba->type], prog,
+				   &sock);
+    }
     if (ret)
         goto cleanup;
 
@@ -753,23 +882,33 @@ setup_socket(struct bind_address *ba, struct sockaddr *sock_address,
 
     if (ba->type == RPC) {
         conn = verto_get_private(ev);
-        conn->transp = svctcp_create(sock, 0, 0);
+        errno = 0;
+        conn->transp = svc_tli_create(sock, nconf, NULL, 0, 0);
         if (conn->transp == NULL) {
-            ret = errno;
-            krb5_klog_syslog(LOG_ERR, _("Cannot create RPC service: %s"),
-                             strerror(ret));
+            ret = (errno != 0) ? errno : EINVAL;
+            krb5_klog_syslog(LOG_ERR,
+                             _("Cannot create RPC service; continuing"));
             goto cleanup;
         }
 
-        ret = svc_register(conn->transp, ba->rpc_svc_data.prognum,
-                           ba->rpc_svc_data.versnum, ba->rpc_svc_data.dispatch,
-                           0);
-        if (!ret) {
-            ret = errno;
-            krb5_klog_syslog(LOG_ERR, _("Cannot register RPC service: %s"),
-                             strerror(ret));
+        if (!svc_reg(conn->transp, ba->rpc_svc_data.prognum,
+                     ba->rpc_svc_data.versnum, ba->rpc_svc_data.dispatch,
+                     nconf)) {
+            ret = (errno != 0) ? errno : EINVAL;
+            krb5_klog_syslog(LOG_ERR,
+                             _("Cannot register RPC prog %d vers %d on %s; "
+                               "continuing"),
+                             (int) ba->rpc_svc_data.prognum,
+                             (int) ba->rpc_svc_data.versnum,
+                             nconf->nc_netid);
             goto cleanup;
         }
+        krb5_klog_syslog(LOG_INFO,
+                         _("listening on fd %d: %s address %s:%hd "
+                           "(RPC prog %d vers %d)"),
+                         sock, nconf->nc_netid, ba->address, ba->port,
+                         (int) ba->rpc_svc_data.prognum,
+                         (int) ba->rpc_svc_data.versnum);
     }
 
     ev = NULL;
@@ -781,6 +920,8 @@ cleanup:
         close(sock);
     if (ev != NULL)
         verto_del(ev);
+    if (nconf != NULL)
+	freenetconfigent(nconf);
     return ret;
 }
 
--- a/src/lib/kadm5/Makefile.in
+++ b/src/lib/kadm5/Makefile.in
@@ -21,6 +21,7 @@ SRCS =	kadm_err.c \
 	$(srcdir)/chpass_util.c \
 	$(srcdir)/alt_prof.c \
 	$(srcdir)/str_conv.c \
+	$(srcdir)/kadm_host_srv_names.c \
 	$(srcdir)/logger.c
 
 OBJS =	kadm_err.$(OBJEXT) \
@@ -30,6 +31,7 @@ OBJS =	kadm_err.$(OBJEXT) \
 	chpass_util.$(OBJEXT) \
 	alt_prof.$(OBJEXT) \
 	str_conv.$(OBJEXT) \
+	kadm_host_srv_names.$(OBJEXT) \
 	logger.$(OBJEXT)
 
 STLIBOBJS = \
@@ -40,6 +42,7 @@ STLIBOBJS = \
 	chpass_util.o \
 	alt_prof.o \
 	str_conv.o \
+	kadm_host_srv_names.o \
 	logger.o
 
 HDRDIR=$(BUILDTOP)/include/kadm5
--- a/src/lib/kadm5/admin.h
+++ b/src/lib/kadm5/admin.h
@@ -42,7 +42,7 @@
 #define __KADM5_ADMIN_H__
 
 #include        <sys/types.h>
-#include        <gssrpc/rpc.h>
+#include        <rpc/rpc.h>
 #include        <krb5.h>
 #include        <kdb.h>
 #include        <com_err.h>
@@ -64,7 +64,9 @@ KADM5INT_BEGIN_DECLS
 #define KADM5_ADMIN_SERVICE     "kadmin/admin"
 #define KADM5_CHANGEPW_SERVICE  "kadmin/changepw"
 #define KADM5_HIST_PRINCIPAL    "kadmin/history"
-#define KADM5_KIPROP_HOST_SERVICE "kiprop"
+
+#define KADM5_KIPROP_HOST_SERVICE	"kiprop"
+#define	KADM5_ADMIN_HOST_SERVICE	"kadmin"
 
 typedef krb5_principal  kadm5_princ_t;
 typedef char            *kadm5_policy_t;
@@ -465,6 +467,21 @@ kadm5_ret_t    kadm5_free_key_data(void *server_handle,
 kadm5_ret_t    kadm5_free_name_list(void *server_handle, char **names,
                                     int count);
 
+kadm5_ret_t
+kadm5_get_adm_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+kadm5_ret_t
+kadm5_get_cpw_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+kadm5_ret_t
+kadm5_get_kiprop_host_srv_names(krb5_context context,
+		             const char *realm, char ***host_service_names);
+
+void
+free_srv_names(char **srv_names);
+
 krb5_error_code kadm5_init_krb5_context (krb5_context *);
 
 krb5_error_code kadm5_init_iprop(void *server_handle, char **db_args);
--- a/src/lib/kadm5/alt_prof.c
+++ b/src/lib/kadm5/alt_prof.c
@@ -754,10 +754,17 @@ krb5_error_code kadm5_get_config_params(krb5_context context,
         params.mask |= KADM5_CONFIG_IPROP_ENABLED;
         params.iprop_enabled = params_in->iprop_enabled;
     } else {
-        if (aprofile &&
-            !krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)) {
-            params.iprop_enabled = bvalue;
-            params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+        if (aprofile) {
+            if(!krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)) {
+                params.iprop_enabled = bvalue;
+                params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+            } else {
+                hierarchy[2] = KRB5_CONF_SUNW_DBPROP_ENABLE;
+                if(!krb5_aprof_get_boolean(aprofile, hierarchy, TRUE, &bvalue)){
+                    params.iprop_enabled = bvalue;
+                    params.mask |= KADM5_CONFIG_IPROP_ENABLED;
+                }
+            }
         }
     }
 
@@ -786,18 +793,30 @@ krb5_error_code kadm5_get_config_params(krb5_context context,
         params.mask |= KADM5_CONFIG_ULOG_SIZE;
         params.iprop_ulogsize = params_in->iprop_ulogsize;
     } else {
-        if (aprofile != NULL &&
-            !krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue)) {
-            if (ivalue <= 0)
-                params.iprop_ulogsize = DEF_ULOGENTRIES;
-            else
-                params.iprop_ulogsize = ivalue;
-            params.mask |= KADM5_CONFIG_ULOG_SIZE;
+        if (aprofile != NULL) {
+            if (!krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue)) {
+                if (ivalue <= 0)
+                    params.iprop_ulogsize = DEF_ULOGENTRIES;
+                else
+                    params.iprop_ulogsize = ivalue;
+                params.mask |= KADM5_CONFIG_ULOG_SIZE;
+            } else {
+                hierarchy[2] = KRB5_CONF_SUNW_DBPROP_MASTER_ULOGSIZE;
+                if (!krb5_aprof_get_int32(aprofile, hierarchy, TRUE, &ivalue)) {
+                    if (ivalue <= 0)
+                        params.iprop_ulogsize = DEF_ULOGENTRIES;
+                    else
+                        params.iprop_ulogsize = ivalue;
+                    params.mask |= KADM5_CONFIG_ULOG_SIZE;
+                }
+            }
         }
     }
 
     GET_DELTAT_PARAM(iprop_poll_time, KADM5_CONFIG_POLL_TIME,
-                     KRB5_CONF_IPROP_SLAVE_POLL, 2 * 60); /* 2m */
+                     KRB5_CONF_SUNW_DBPROP_SLAVE_POLL, 2 * 60); /* 2m */
+    GET_DELTAT_PARAM(iprop_poll_time, KADM5_CONFIG_POLL_TIME,
+                     KRB5_CONF_IPROP_SLAVE_POLL, params.iprop_poll_time);
 
     *params_out = params;
 
--- a/src/lib/kadm5/clnt/Makefile.in
+++ b/src/lib/kadm5/clnt/Makefile.in
@@ -7,12 +7,11 @@ LIBMAJOR=11
 LIBMINOR=0
 STOBJLISTS=../OBJS.ST OBJS.ST
 SHLIB_EXPDEPS=\
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libgssapi_krb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT) \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
 	$(COM_ERR_DEPLIB) $(SUPPORT_LIBDEP)
-SHLIB_EXPLIBS=-lgssrpc -lgssapi_krb5 -lkrb5 -lk5crypto $(SUPPORT_LIB) -lcom_err $(LIBS)
+SHLIB_EXPLIBS= -lgssapi_krb5 -lkrb5 -lk5crypto $(SUPPORT_LIB) -lcom_err $(LIBS)
 RELDIR=kadm5/clnt
 
 ##DOSBUILDTOP = ..\..\..
--- a/src/lib/kadm5/clnt/client_init.c
+++ b/src/lib/kadm5/clnt/client_init.c
@@ -44,12 +44,12 @@
 #include <iprop_hdr.h>
 #include "iprop.h"
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <gssapi/gssapi.h>
 #include <gssapi/gssapi_krb5.h>
-#include <gssrpc/auth_gssapi.h>
 
 #define ADM_CCACHE  "/tmp/ovsec_adm.XXXXXX"
+#define KADMIND_CONNECT_TIMEOUT	25
 
 enum init_type { INIT_PASS, INIT_SKEY, INIT_CREDS, INIT_ANONYMOUS };
 
@@ -138,9 +138,377 @@ kadm5_init_with_skey(krb5_context context, char *client_name,
                     server_handle);
 }
 
+/*
+ * Open an fd for the given address and connect asynchronously. Wait
+ * KADMIND_CONNECT_TIMEOUT seconds or till it succeeds. If it succeeds
+ * change fd to blocking and return it, else return -1.
+ */
+static int
+get_connection(struct netconfig *nconf, struct netbuf netaddr)
+{
+	struct t_info tinfo;
+	struct t_call sndcall;
+	struct t_call *rcvcall = NULL;
+	int connect_time;
+	int flags;
+	int fd;
+
+	(void) memset(&tinfo, 0, sizeof (tinfo));
+
+	/* we'l open with O_NONBLOCK and avoid an fcntl */
+	fd = t_open(nconf->nc_device, O_RDWR | O_NONBLOCK, &tinfo);
+	if (fd == -1) {
+		return (-1);
+	}
+
+	if (t_bind(fd, (struct t_bind *)NULL, (struct t_bind *)NULL) == -1) {
+		(void) t_close(fd);
+		return (-1);
+	}
+
+	/* we can't connect unless fd is in IDLE state */
+	if (t_getstate(fd) != T_IDLE) {
+		(void) t_close(fd);
+		return (-1);
+	}
+
+	/* setup connect parameters */
+	netaddr.len = netaddr.maxlen = __rpc_get_a_size(tinfo.addr);
+	sndcall.addr = netaddr;
+	sndcall.opt.len = sndcall.udata.len = 0;
+
+	/* we wait for KADMIND_CONNECT_TIMEOUT seconds from now */
+	connect_time = time(NULL) + KADMIND_CONNECT_TIMEOUT;
+	if (t_connect(fd, &sndcall, rcvcall) != 0) {
+		if (t_errno != TNODATA) {
+			(void) t_close(fd);
+			return (-1);
+		}
+	}
+
+	/* loop till success or timeout */
+	for (;;) {
+		if (t_rcvconnect(fd, rcvcall) == 0)
+			break;
+
+		if (t_errno != TNODATA || time(NULL) > connect_time) {
+			/* we have either timed out or caught an error */
+			(void) t_close(fd);
+			if (rcvcall != NULL)
+				t_free((char *)rcvcall, T_CALL);
+			return (-1);
+		}
+		sleep(1);
+	}
+
+	/* make the fd blocking (synchronous) */
+	flags = fcntl(fd, F_GETFL, 0);
+	(void) fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);
+	if (rcvcall != NULL)
+		t_free((char *)rcvcall, T_CALL);
+	return (fd);
+}
+
+/*
+ * Wrapper over clnt_tli_create.
+ * Opens a connection to host:port and calls clnt_tli_create.
+ * Returns a client handle or NULL on failure.
+ */
+static CLIENT*
+clnt_create_with_port(const char *host, int port,
+		      const rpcprog_t prog, const rpcvers_t vers)
+{
+	struct netbuf netaddr;
+	struct hostent *hp;
+	int fd;
+	struct sockaddr_in addr;
+	struct sockaddr_in *sin;
+	struct netconfig *nconf;
+	void *handlep = NULL;
+	CLIENT *clnt = NULL;
+
+	hp = gethostbyname(host);
+	if (hp == (struct hostent *)NULL) {
+		goto cleanup;
+	}
+
+	memset(&addr, 0, sizeof (addr));
+	addr.sin_family = hp->h_addrtype;
+	(void) memcpy((char *)&addr.sin_addr, (char *)hp->h_addr,
+		    sizeof (addr.sin_addr));
+	addr.sin_port = htons((ushort_t)port);
+	sin = &addr;
+	if ((handlep = setnetconfig()) == (void *) NULL) {
+		goto cleanup;
+	}
+
+	while (nconf = getnetconfig(handlep)) {
+		if ((nconf->nc_semantics == NC_TPI_COTS_ORD) &&
+		    (strcmp(nconf->nc_protofmly, NC_INET) == 0) &&
+		    (strcmp(nconf->nc_proto, NC_TCP) == 0))
+			break;
+	}
+
+	if (nconf == (struct netconfig *)NULL)
+		goto cleanup;
+
+	/* Transform addr to netbuf */
+	(void) memset(&netaddr, 0, sizeof (netaddr));
+	netaddr.buf = (char *)sin;
+
+	/* get an fd connected to the given address */
+	fd =  get_connection(nconf, netaddr);
+	if (fd == -1) {
+		goto cleanup;
+	}
+
+	clnt = clnt_tli_create(fd, nconf, NULL, prog, vers, 0, 0);
+	if (clnt == NULL) {
+		clnt_pcreateerror("ERROR:");
+		(void) t_close(fd);
+		goto cleanup;
+	}
+	/*
+	 * The rpc-handle was created on an fd opened and connected
+	 * by us, so we have to explicitly tell rpc to close it.
+	 */
+	if (clnt_control(clnt, CLSET_FD_CLOSE, NULL) != TRUE) {
+		clnt_destroy(clnt);
+		clnt = NULL;
+		(void) t_close(fd);
+	}
+
+cleanup:
+	if (handlep != (void *) NULL)
+		(void) endnetconfig(handlep);
+
+	return (clnt);
+}
+
+/*
+ * Open an RPCSEC_GSS connection and
+ * get a client handle to use for future RPCSEC calls.
+ *
+ * This function is only used when changing passwords and
+ * the kpasswd_protocol is RPCSEC_GSS
+ */
+static int
+_kadm5_initialize_rpcsec_gss_handle(kadm5_server_handle_t handle,
+				    char *client_name,
+				    char *service_name)
+{
+	int code = 0;
+	generic_ret r = { 0, 0 };
+	char *ccname_orig = NULL;
+	boolean_t iprop_enable = B_FALSE;
+	char mech[] = "kerberos_v5";
+	gss_OID mech_oid;
+	gss_OID_set_desc oid_set;
+	gss_name_t gss_client;
+	gss_buffer_desc input_name;
+	gss_cred_id_t gss_client_creds = GSS_C_NO_CREDENTIAL;
+	rpc_gss_options_req_t   options_req;
+	rpc_gss_options_ret_t   options_ret;
+	rpc_gss_service_t service = rpc_gss_svc_privacy;
+	OM_uint32 gssstat, minor_stat;
+	enum clnt_stat rpc_err_code;
+	char *server;
+	int port;
+	struct timeval timeout;
+
+        /* service name is service/host */
+        server = strpbrk(service_name, "/");
+        if (!server) {
+		code = KADM5_BAD_SERVER_NAME;
+		goto cleanup;
+        }
+
+	/* but rpc_gss_secreate expects service@host */
+	*server++ = '@';
+
+ 	/*
+	 * If the service_name and client_name are iprop-centric
+	 * use iprop service; otherwise use kadmin service.
+	 */
+	if ((strstr(service_name, KIPROP_SVC_NAME) != NULL) &&
+	    (strstr(client_name, KIPROP_SVC_NAME) != NULL)) {
+		iprop_enable = B_TRUE;
+	}
+
+	/*
+	 * iprop fallback logic:
+	 *    - if iprop_port is configured, connect to iprop_port
+	 *    - if not, query remote rpc/bind
+	 *    - if that fails, try consuming iprop service on kadmin port
+	 */
+	if (iprop_enable && handle->params.iprop_port != 0){
+		port = handle->params.iprop_port;
+		handle->clnt = clnt_create_with_port(server, port,
+						     KRB5_IPROP_PROG,
+						     KRB5_IPROP_VERS);
+	} else if (iprop_enable && handle->params.iprop_port == 0) {
+		/* using remote rpc/bind first */
+		handle->clnt = clnt_create(server, KRB5_IPROP_PROG,
+					   KRB5_IPROP_VERS, NC_TCP);
+		if (handle->clnt == NULL) {
+			/* possible rpc/bind failure, try kadmin port */
+			port = handle->params.kadmind_port;
+			handle->clnt = clnt_create_with_port(server, port,
+							     KRB5_IPROP_PROG,
+							     KRB5_IPROP_VERS);
+		}
+	} else {
+		/* kadmin service */
+		port = handle->params.kadmind_port;
+		handle->clnt = clnt_create_with_port(server, port,
+				                     KADM, KADMVERS);
+	}
+
+	if (handle->clnt == NULL) {
+		code = KADM5_RPC_ERROR;
+		goto error;
+	}
+
+	/* Set a one-hour timeout. */
+	timeout.tv_sec = 3600;
+	timeout.tv_usec = 0;
+	(void)clnt_control(handle->clnt, CLSET_TIMEOUT, (char *)&timeout);
+
+	handle->lhandle->clnt = handle->clnt;
+
+	/* now that handle->clnt is set, we can check the handle */
+	if (code = _kadm5_check_handle((void *) handle))
+		goto error;
+
+	/*
+	 * The RPC connection is open; establish the GSS-API
+	 * authentication context.
+	 */
+	/* use the kadm5 cache */
+	gssstat = gss_krb5_ccache_name(&minor_stat, handle->cache_name,
+                                       (const char **)&ccname_orig);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+	if (ccname_orig)
+		ccname_orig = strdup(ccname_orig);
+
+	input_name.value = client_name;
+	input_name.length = strlen((char *)input_name.value) + 1;
+	gssstat = gss_import_name(&minor_stat, &input_name,
+				(gss_OID)gss_nt_krb5_name, &gss_client);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+
+	if (!rpc_gss_mech_to_oid(mech, (rpc_gss_OID *)&mech_oid)) {
+		(void) gss_release_name(&minor_stat, &gss_client);
+		goto error;
+	}
+
+	oid_set.count = 1;
+	oid_set.elements = mech_oid;
+
+	gssstat = gss_acquire_cred(&minor_stat, gss_client, 0,
+				&oid_set, GSS_C_INITIATE,
+				&gss_client_creds, NULL, NULL);
+	(void) gss_release_name(&minor_stat, &gss_client);
+	if (gssstat != GSS_S_COMPLETE) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+	options_req.my_cred = gss_client_creds;
+	options_req.req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG;
+	options_req.time_req = 0;
+	options_req.input_channel_bindings = NULL;
+#ifndef INIT_TEST
+	handle->clnt->cl_auth = rpc_gss_seccreate(handle->clnt,
+						service_name,
+						mech,
+						service,
+						NULL,
+						&options_req,
+						&options_ret);
+#endif /* ! INIT_TEST */
+
+	if (ccname_orig) {
+		gssstat = gss_krb5_ccache_name(&minor_stat, ccname_orig, NULL);
+		free(ccname_orig);
+		if (gssstat != GSS_S_COMPLETE) {
+			code = KADM5_GSS_ERROR;
+			goto error;
+		}
+	} else {
+		gssstat = gss_krb5_ccache_name(&minor_stat, NULL, NULL);
+		if (gssstat != GSS_S_COMPLETE) {
+			code = KADM5_GSS_ERROR;
+			goto error;
+		}
+	}
+
+	if (handle->clnt->cl_auth == NULL) {
+		code = KADM5_GSS_ERROR;
+		goto error;
+	}
+
+	/*
+	 * Bypass the remainder of the code and return straightaway
+	 * if the gss service requested is kiprop
+	 */
+	if (iprop_enable == B_TRUE) {
+		code = 0;
+		goto cleanup;
+	}
+
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+		code = KADM5_RPC_ERROR;
+		goto error;
+	}
+
+    /* Drop down to v3 wire protocol if server does not support v4 */
+    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
+        handle->api_version == KADM5_API_VERSION_4) {
+        handle->api_version = KADM5_API_VERSION_3;
+	memset(&r, 0, sizeof(generic_ret));
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+            code = KADM5_RPC_ERROR;
+            goto error;
+        }
+    }
+
+    /* Drop down to v2 wire protocol if server does not support v3 */
+    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
+        handle->api_version == KADM5_API_VERSION_3) {
+        handle->api_version = KADM5_API_VERSION_2;
+	memset(&r, 0, sizeof(generic_ret));
+	if (init_2(&handle->api_version, &r, handle->clnt)) {
+            code = KADM5_RPC_ERROR;
+            goto error;
+        }
+    }
+
+	if (r.code) {
+		code = r.code;
+		goto error;
+	}
+error:
+cleanup:
+	/*
+	 * gss_client_creds is freed only when there is an error condition,
+	 * given that rpc_gss_seccreate() will assign the cred pointer to the
+	 * my_cred member in the auth handle's private data structure.
+	 */
+	if (code && (gss_client_creds != GSS_C_NO_CREDENTIAL))
+		(void) gss_release_cred(&minor_stat, &gss_client_creds);
+
+	return (code);
+}
+
 static kadm5_ret_t
 init_any(krb5_context context, char *client_name, enum init_type init_type,
-         char *pass, krb5_ccache ccache_in, char *service_name,
+         char *pass, krb5_ccache ccache_in, char *svcname_in,
          kadm5_config_params *params_in, krb5_ui_4 struct_version,
          krb5_ui_4 api_version, char **db_args, void **server_handle)
 {
@@ -152,13 +520,12 @@ init_any(krb5_context context, char *client_name, enum init_type init_type,
     rpcvers_t rpc_vers;
     krb5_ccache ccache;
     krb5_principal client = NULL, server = NULL;
-    struct timeval timeout;
 
     kadm5_server_handle_t handle;
     kadm5_config_params params_local;
 
     int code = 0;
-    generic_ret r = { 0, 0 };
+    char svcname[BUFSIZ];
 
     initialize_ovk_error_table();
 /*      initialize_adb_error_table(); */
@@ -226,104 +593,27 @@ init_any(krb5_context context, char *client_name, enum init_type init_type,
     if (code)
         goto error;
 
-    /*
-     * Get credentials.  Also does some fallbacks in case kadmin/fqdn
-     * principal doesn't exist.
-     */
-    code = get_init_creds(handle, client, init_type, pass, ccache_in,
-                          service_name, handle->params.realm, &server);
-    if (code)
-        goto error;
-
-    /* If the service_name and client_name are iprop-centric, use the iprop
-     * port and RPC identifiers. */
-    iprop_enable = (service_name != NULL &&
-                    strstr(service_name, KIPROP_SVC_NAME) != NULL &&
-                    strstr(client_name, KIPROP_SVC_NAME) != NULL);
-    if (iprop_enable) {
-        port = handle->params.iprop_port;
-        rpc_prog = KRB5_IPROP_PROG;
-        rpc_vers = KRB5_IPROP_VERS;
+    /* NULL svcname means use host-based. */
+    if (svcname_in == NULL) {
+        code = kadm5_get_admin_service_name(handle->context,
+                                            handle->params.realm,
+                                            svcname, sizeof(svcname));
+        if (code)
+            goto error;
     } else {
-        port = handle->params.kadmind_port;
-        rpc_prog = KADM;
-        rpc_vers = KADMVERS;
+        strncpy(svcname, svcname_in, sizeof(svcname));
+        svcname[sizeof(svcname)-1] = '\0';
     }
 
-    code = connect_to_server(handle->params.admin_server, port, &fd);
+    /* Get credentials. */
+    code = get_init_creds(handle, client, init_type, pass, ccache_in,
+                          svcname, handle->params.realm, &server);
     if (code)
         goto error;
 
-    handle->clnt = clnttcp_create(NULL, rpc_prog, rpc_vers, &fd, 0, 0);
-    if (handle->clnt == NULL) {
-        code = KADM5_RPC_ERROR;
-#ifdef DEBUG
-        clnt_pcreateerror("clnttcp_create");
-#endif
-        goto error;
-    }
-
-    /* Set a one-hour timeout. */
-    timeout.tv_sec = 3600;
-    timeout.tv_usec = 0;
-    (void)clnt_control(handle->clnt, CLSET_TIMEOUT, &timeout);
-
-    handle->client_socket = fd;
-    handle->lhandle->clnt = handle->clnt;
-    handle->lhandle->client_socket = fd;
-
-    /* now that handle->clnt is set, we can check the handle */
-    if ((code = _kadm5_check_handle((void *) handle)))
-        goto error;
-
-    /*
-     * The RPC connection is open; establish the GSS-API
-     * authentication context.
-     */
-    code = setup_gss(handle, params_in,
-                     (init_type == INIT_CREDS) ? client : NULL, server);
-    if (code)
-        goto error;
-
-    /*
-     * Bypass the remainder of the code and return straightaway
-     * if the gss service requested is kiprop
-     */
-    if (iprop_enable) {
-        code = 0;
-        *server_handle = (void *) handle;
-        goto cleanup;
-    }
-
-    if (init_2(&handle->api_version, &r, handle->clnt)) {
-        code = KADM5_RPC_ERROR;
-#ifdef DEBUG
-        clnt_perror(handle->clnt, "init_2 null resp");
-#endif
-        goto error;
-    }
-    /* Drop down to v3 wire protocol if server does not support v4 */
-    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
-        handle->api_version == KADM5_API_VERSION_4) {
-        handle->api_version = KADM5_API_VERSION_3;
-        memset(&r, 0, sizeof(generic_ret));
-        if (init_2(&handle->api_version, &r, handle->clnt)) {
-            code = KADM5_RPC_ERROR;
-            goto error;
-        }
-    }
-    /* Drop down to v2 wire protocol if server does not support v3 */
-    if (r.code == KADM5_NEW_SERVER_API_VERSION &&
-        handle->api_version == KADM5_API_VERSION_3) {
-        handle->api_version = KADM5_API_VERSION_2;
-        memset(&r, 0, sizeof(generic_ret));
-        if (init_2(&handle->api_version, &r, handle->clnt)) {
-            code = KADM5_RPC_ERROR;
-            goto error;
-        }
-    }
-    if (r.code) {
-        code = r.code;
+    code = _kadm5_initialize_rpcsec_gss_handle(handle, client_name,
+                                               svcname);
+    if (code != 0) {
         goto error;
     }
 
@@ -364,31 +654,17 @@ cleanup:
     return code;
 }
 
-/* Get initial credentials for authenticating to server.  Perform fallback from
- * kadmin/fqdn to kadmin/admin if svcname_in is NULL. */
+/* Get initial credentials for authenticating to server. */
 static kadm5_ret_t
 get_init_creds(kadm5_server_handle_t handle, krb5_principal client,
                enum init_type init_type, char *pass, krb5_ccache ccache_in,
-               char *svcname_in, char *realm, krb5_principal *server_out)
+               char *svcname, char *realm, krb5_principal *server_out)
 {
     kadm5_ret_t code;
     krb5_ccache ccache = NULL;
-    char svcname[BUFSIZ];
 
     *server_out = NULL;
 
-    /* NULL svcname means use host-based. */
-    if (svcname_in == NULL) {
-        code = kadm5_get_admin_service_name(handle->context,
-                                            handle->params.realm,
-                                            svcname, sizeof(svcname));
-        if (code)
-            goto error;
-    } else {
-        strncpy(svcname, svcname_in, sizeof(svcname));
-        svcname[sizeof(svcname)-1] = '\0';
-    }
-
     /*
      * Acquire a service ticket for svcname@realm for client, using password
      * pass (which could be NULL), and create a ccache to store them in.  If
@@ -426,12 +702,6 @@ get_init_creds(kadm5_server_handle_t handle, krb5_principal client,
 
     code = gic_iter(handle, init_type, ccache, client, pass, svcname, realm,
                     server_out);
-    if ((code == KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN
-         || code == KRB5_CC_NOTFOUND) && svcname_in == NULL) {
-        /* Retry with old host-independent service principal. */
-        code = gic_iter(handle, init_type, ccache, client, pass,
-                        KADM5_ADMIN_SERVICE, realm, server_out);
-    }
     /* Improved error messages */
     if (code == KRB5KRB_AP_ERR_BAD_INTEGRITY) code = KADM5_BAD_PASSWORD;
     if (code == KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN)
@@ -698,6 +968,27 @@ rpc_auth(kadm5_server_handle_t handle, kadm5_config_params *params_in,
          gss_cred_id_t gss_client_creds, gss_name_t gss_target)
 {
     OM_uint32 gssstat, minor_stat;
+    gss_buffer_desc buf;
+    rpc_gss_options_req_t options_req;
+    rpc_gss_options_ret_t options_ret;
+
+    if (gss_display_name(&minor_stat, gss_target, &buf, NULL) != GSS_S_COMPLETE)
+	    return;
+
+    options_req.my_cred = gss_client_creds;
+    options_req.req_flags = GSS_C_MUTUAL_FLAG | GSS_C_REPLAY_FLAG;
+    options_req.time_req = 0;
+    options_req.input_channel_bindings = NULL;
+    handle->clnt->cl_auth = rpc_gss_seccreate(handle->clnt,
+		                              (char*) buf.value,
+					      "kerberos_v5",
+					      rpc_gss_svc_privacy,
+					      NULL,
+					      &options_req,
+					      &options_ret);
+
+    gss_release_buffer(&minor_stat, &buf);
+#if 0
     struct rpc_gss_sec sec;
 
     /* Allow unauthenticated option for testing. */
@@ -732,6 +1023,7 @@ rpc_auth(kadm5_server_handle_t handle, kadm5_config_params *params_in,
                                                GSS_C_MUTUAL_FLAG
                                                | GSS_C_REPLAY_FLAG,
                                                0, NULL, NULL, NULL);
+#endif
 }
 
 kadm5_ret_t
--- a/src/lib/kadm5/clnt/client_principal.c
+++ b/src/lib/kadm5/clnt/client_principal.c
@@ -5,7 +5,7 @@
  * $Header$
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #ifdef HAVE_MEMORY_H
--- a/src/lib/kadm5/clnt/client_rpc.c
+++ b/src/lib/kadm5/clnt/client_rpc.c
@@ -1,5 +1,5 @@
 /* -*- mode: c; c-file-style: "bsd"; indent-tabs-mode: t -*- */
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <kadm5/kadm_rpc.h>
 #include <krb5.h>
 #include <kadm5/admin.h>
--- a/src/lib/kadm5/clnt/clnt_policy.c
+++ b/src/lib/kadm5/clnt/clnt_policy.c
@@ -5,7 +5,7 @@
  * $Header$
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #include    "client_internal.h"
--- a/src/lib/kadm5/clnt/clnt_privs.c
+++ b/src/lib/kadm5/clnt/clnt_privs.c
@@ -7,7 +7,7 @@
  *
  */
 
-#include    <gssrpc/rpc.h>
+#include    <rpc/rpc.h>
 #include    <kadm5/admin.h>
 #include    <kadm5/kadm_rpc.h>
 #include    "client_internal.h"
--- a/src/lib/kadm5/deps
+++ b/src/lib/kadm5/deps
@@ -98,6 +98,20 @@ str_conv.so str_conv.po $(OUTPRE)str_conv.$(OBJEXT): \
   $(top_srcdir)/include/krb5/plugin.h $(top_srcdir)/include/port-sockets.h \
   $(top_srcdir)/include/socket-utils.h admin_internal.h \
   str_conv.c
+kadm_host_srv_names.so kadm_host_srv_names.po $(OUTPRE)kadm_host_srv_names.$(OBJEXT): \
+  $(BUILDTOP)/include/autoconf.h $(BUILDTOP)/include/gssapi/gssapi.h \
+  $(BUILDTOP)/include/kadm5/chpass_util_strings.h $(BUILDTOP)/include/kadm5/kadm_err.h \
+  $(BUILDTOP)/include/krb5/krb5.h $(BUILDTOP)/include/osconf.h \
+  $(BUILDTOP)/include/profile.h $(COM_ERR_DEPS) $(srcdir)/../krb5/os/os-proto.h \
+  $(top_srcdir)/include/fake-addrinfo.h $(top_srcdir)/include/k5-buf.h \
+  $(top_srcdir)/include/k5-err.h $(top_srcdir)/include/k5-gmt_mktime.h \
+  $(top_srcdir)/include/k5-int-pkinit.h $(top_srcdir)/include/k5-int.h \
+  $(top_srcdir)/include/k5-platform.h $(top_srcdir)/include/k5-plugin.h \
+  $(top_srcdir)/include/k5-thread.h $(top_srcdir)/include/k5-trace.h \
+  $(top_srcdir)/include/kdb.h $(top_srcdir)/include/krb5.h \
+  $(top_srcdir)/include/krb5/authdata_plugin.h $(top_srcdir)/include/krb5/locate_plugin.h \
+  $(top_srcdir)/include/krb5/plugin.h $(top_srcdir)/include/port-sockets.h \
+  $(top_srcdir)/include/socket-utils.h admin.h kadm_host_srv_names.c
 logger.so logger.po $(OUTPRE)logger.$(OBJEXT): $(BUILDTOP)/include/autoconf.h \
   $(BUILDTOP)/include/krb5/krb5.h $(BUILDTOP)/include/osconf.h \
   $(BUILDTOP)/include/profile.h $(COM_ERR_DEPS) $(top_srcdir)/include/adm_proto.h \
--- a/src/lib/kadm5/kadm_rpc.h
+++ b/src/lib/kadm5/kadm_rpc.h
@@ -2,7 +2,7 @@
 #ifndef __KADM_RPC_H__
 #define __KADM_RPC_H__
 
-#include <gssrpc/types.h>
+#include <rpc/types.h>
 
 #include	<krb5.h>
 #include	<kadm5/admin.h>
@@ -415,4 +415,8 @@ extern bool_t xdr_kadm5_key_data ();
 extern bool_t xdr_getpkeys_arg ();
 extern bool_t xdr_getpkeys_ret ();
 
+/* Solaris libc doesn't define 32 bit version of xdr_int and xdr_u_int */
+#define	xdr_int32 xdr_int
+#define	xdr_u_int32 xdr_u_int
+
 #endif /* __KADM_RPC_H__ */
--- a/src/lib/kadm5/kadm_rpc_xdr.c
+++ b/src/lib/kadm5/kadm_rpc_xdr.c
@@ -3,7 +3,7 @@
  * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved
  */
 
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <krb5.h>
 #include <errno.h>
 #include <kadm5/admin.h>
--- a/src/lib/kadm5/server_internal.h
+++ b/src/lib/kadm5/server_internal.h
@@ -264,4 +264,8 @@ k5_kadm5_hook_rename (krb5_context context,
 
 /** @}*/
 
+/* Solaris Kerberos: symbols available in libkadm5srv_mit */
+extern void xdralloc_create(XDR *xdrs, enum xdr_op op);
+extern caddr_t xdralloc_getdata(XDR *xdrs);
+
 #endif /* __KADM5_SERVER_INTERNAL_H__ */
--- a/src/lib/kadm5/srv/Makefile.in
+++ b/src/lib/kadm5/srv/Makefile.in
@@ -14,13 +14,12 @@ LIBMINOR=0
 STOBJLISTS=../OBJS.ST OBJS.ST
 
 SHLIB_EXPDEPS=\
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libgssapi_krb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkdb5$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT) \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
 	$(COM_ERR_DEPLIB) $(SUPPORT_LIBDEP)
-SHLIB_EXPLIBS =	-lgssrpc -lgssapi_krb5 -lkdb5 $(KDB5_DB_LIB) \
+SHLIB_EXPLIBS =	 -lgssapi_krb5 -lkdb5 $(KDB5_DB_LIB) \
 		-lkrb5 -lk5crypto $(SUPPORT_LIB) -lcom_err @GEN_LIB@ $(LIBS)
 RELDIR=kadm5/srv
 
@@ -37,6 +36,8 @@ SRCS =	$(srcdir)/pwqual.c \
 	$(srcdir)/server_init.c \
 	$(srcdir)/svr_iters.c \
 	$(srcdir)/svr_chpass_util.c \
+	$(srcdir)/xdr_alloc.c \
+	$(srcdir)/dyn.c \
 	$(srcdir)/adb_xdr.c 
 
 OBJS =	pwqual.$(OBJEXT) \
@@ -52,6 +53,8 @@ OBJS =	pwqual.$(OBJEXT) \
 	server_init.$(OBJEXT) \
 	svr_iters.$(OBJEXT) \
 	svr_chpass_util.$(OBJEXT) \
+	xdr_alloc.$(OBJEXT) \
+	dyn.$(OBJEXT) \
 	adb_xdr.$(OBJEXT) 
 
 STLIBOBJS = \
@@ -68,6 +71,8 @@ STLIBOBJS = \
 	server_init.o \
 	svr_iters.o \
 	svr_chpass_util.o \
+	xdr_alloc.o \
+	dyn.o \
 	adb_xdr.o
 
 all-unix: all-liblinks
--- a/src/lib/kadm5/srv/adb_xdr.c
+++ b/src/lib/kadm5/srv/adb_xdr.c
@@ -7,7 +7,7 @@
 
 #include <sys/types.h>
 #include <krb5.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include	"server_internal.h"
 #include "admin_xdr.h"
 #ifdef HAVE_MEMORY_H
--- a/src/lib/kadm5/srv/server_init.c
+++ b/src/lib/kadm5/srv/server_init.c
@@ -233,8 +233,7 @@ kadm5_ret_t kadm5_init(krb5_context context, char *client_name, char *pass,
 
 #define IPROP_REQUIRED_PARAMS                   \
     (KADM5_CONFIG_IPROP_ENABLED |               \
-     KADM5_CONFIG_IPROP_LOGFILE |               \
-     KADM5_CONFIG_IPROP_PORT)
+     KADM5_CONFIG_IPROP_LOGFILE)
 
     if ((handle->params.mask & REQUIRED_PARAMS) != REQUIRED_PARAMS) {
         kadm5_free_config_params(handle->context, &handle->params);
--- a/src/lib/kdb/Makefile.in
+++ b/src/lib/kdb/Makefile.in
@@ -14,9 +14,8 @@ RELDIR=kdb
 
 SHLIB_EXPDEPS = \
 	$(TOPLIBD)/libk5crypto$(SHLIBEXT) \
-	$(TOPLIBD)/libgssrpc$(SHLIBEXT) \
 	$(TOPLIBD)/libkrb5$(SHLIBEXT)
-SHLIB_EXPLIBS=-lgssrpc -lkrb5 -lk5crypto -lcom_err $(SUPPORT_LIB) $(DL_LIB) $(LIBS)
+SHLIB_EXPLIBS= -lkrb5 -lk5crypto -lcom_err $(SUPPORT_LIB) $(DL_LIB) $(LIBS)
 
 adb_err.$(OBJEXT): adb_err.c
 adb_err.c adb_err.h: $(srcdir)/adb_err.et
--- a/src/lib/kdb/iprop_xdr.c
+++ b/src/lib/kdb/iprop_xdr.c
@@ -9,6 +9,7 @@
 #pragma GCC diagnostic ignored "-Wunused-variable"
 #endif
 
+#if 0
 static bool_t
 xdr_int16_t (XDR *xdrs, int16_t *objp)
 {
@@ -38,6 +39,7 @@ xdr_uint32_t (XDR *xdrs, uint32_t *objp)
         return FALSE;
     return TRUE;
 }
+#endif
 
 bool_t
 xdr_utf8str_t (XDR *xdrs, utf8str_t *objp)
--- a/src/lib/krb5/os/changepw.c
+++ b/src/lib/krb5/os/changepw.c
@@ -57,7 +57,7 @@ struct sendto_callback_context {
  * Wrapper function for the two backends
  */
 
-static krb5_error_code
+krb5_error_code
 locate_kpasswd(krb5_context context, const krb5_data *realm,
                struct serverlist *serverlist, krb5_boolean no_udp)
 {
--- a/src/lib/krb5/os/locate_kdc.c
+++ b/src/lib/krb5/os/locate_kdc.c
@@ -837,6 +837,14 @@ k5_locate_kdc(krb5_context context, const krb5_data *realm,
     return k5_locate_server(context, realm, serverlist, stype, no_udp);
 }
 
+krb5_error_code
+k5_locate_kadmin(krb5_context context, const krb5_data *realm,
+                 struct serverlist *serverlist)
+{
+    return k5_locate_server(context, realm, serverlist, locate_service_kadmin,
+                            1);
+}
+
 krb5_boolean
 k5_kdc_is_master(krb5_context context, const krb5_data *realm,
                  struct server_entry *server)
--- a/src/lib/krb5/os/sn2princ.c
+++ b/src/lib/krb5/os/sn2princ.c
@@ -66,6 +66,7 @@ krb5_expand_hostname(krb5_context context, const char *host,
 
     canonhost = host;
     if (context->dns_canonicalize_hostname) {
+#if 0 /* force DNS lookup */
         /* Try a forward lookup of the hostname. */
         memset(&hint, 0, sizeof(hint));
         hint.ai_flags = AI_CANONNAME;
--- a/src/lib/rpc/xdr_alloc.c
+++ b/src/lib/rpc/xdr_alloc.c
@@ -35,18 +35,23 @@
  * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved.
  */
 
-#include <gssrpc/types.h>
-#include <gssrpc/xdr.h>
+#include <sys/types.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+#include <inttypes.h>
 #include "dyn.h"
 
 static bool_t	xdralloc_putlong(XDR *, long *);
-static bool_t	xdralloc_putbytes(XDR *, caddr_t, unsigned int);
+static bool_t	xdralloc_putbytes(XDR *, caddr_t, int);
 static unsigned int	xdralloc_getpos(XDR *);
 static rpc_inline_t *	xdralloc_inline(XDR *, int);
 static void	xdralloc_destroy(XDR *);
+static bool_t	xdralloc_putint32(XDR *, int32_t *);
 static bool_t	xdralloc_notsup_getlong(XDR *, long *);
-static bool_t	xdralloc_notsup_getbytes(XDR *, caddr_t, unsigned int);
+static bool_t	xdralloc_notsup_getbytes(XDR *, caddr_t, int);
 static bool_t	xdralloc_notsup_setpos(XDR *, unsigned int);
+static bool_t	xdralloc_notsup_getint32(XDR *, int32_t *);
+static bool_t	xdralloc_notsup_control(XDR *, int, void *);
 static struct	xdr_ops xdralloc_ops = {
      xdralloc_notsup_getlong,
      xdralloc_putlong,
@@ -56,6 +61,11 @@ static struct	xdr_ops xdralloc_ops = {
      xdralloc_notsup_setpos,
      xdralloc_inline,
      xdralloc_destroy,
+     xdralloc_notsup_control,
+#if defined(_LP64)
+     xdralloc_notsup_getint32,
+     xdralloc_putint32,
+#endif
 };
 
 /*
@@ -96,7 +106,12 @@ static bool_t xdralloc_putlong(
      register XDR *xdrs,
      long *lp)
 {
-     int l = htonl((uint32_t) *lp); /* XXX need bounds checking */
+#if defined(_LP64)
+     if ((*lp > INT32_MAX) || (*lp < INT32_MIN))
+          return FALSE;
+#endif
+
+     int l = htonl((uint32_t) *lp);
 
      /* XXX assumes sizeof(int)==4 */
      if (DynInsert((DynObject) xdrs->x_private,
@@ -106,11 +121,33 @@ static bool_t xdralloc_putlong(
      return (TRUE);
 }
 
+#if defined(_LP64)
+static bool_t xdralloc_notsup_getint32(
+     register XDR *xdrs,
+     int32_t *lp)
+{
+     return FALSE;
+}
+
+static bool_t xdralloc_putint32(
+     register XDR *xdrs,
+     int32_t *lp)
+{
+     int l = htonl((uint32_t) *lp);
+
+     /* XXX assumes sizeof(int)==4 */
+     if (DynInsert((DynObject) xdrs->x_private,
+		   DynSize((DynObject) xdrs->x_private), &l,
+		   sizeof(int)) != DYN_OK)
+	  return FALSE;
+     return (TRUE);
+}
+#endif
 
 static bool_t xdralloc_notsup_getbytes(
      register XDR *xdrs,
      caddr_t addr,
-     register unsigned int len)
+     register int len)
 {
      return FALSE;
 }
@@ -119,7 +156,7 @@ static bool_t xdralloc_notsup_getbytes(
 static bool_t xdralloc_putbytes(
      register XDR *xdrs,
      caddr_t addr,
-     register unsigned int len)
+     register int len)
 {
      if (DynInsert((DynObject) xdrs->x_private,
 		   DynSize((DynObject) xdrs->x_private),
@@ -148,3 +185,10 @@ static rpc_inline_t *xdralloc_inline(
 {
      return (rpc_inline_t *) 0;
 }
+
+static bool_t xdralloc_notsup_control(XDR *xdrs,
+     int request,
+     void *info)
+{
+     return FALSE;
+}
--- a/src/plugins/kdb/db2/adb_policy.c
+++ b/src/plugins/kdb/db2/adb_policy.c
@@ -28,6 +28,9 @@
             return cl_ret;                                              \
     }
 
+/* Solaris Kerberos: symbols available from libkadm5srv_mit */
+extern void	xdralloc_create(XDR *, enum xdr_op);
+extern caddr_t	xdralloc_getdata(XDR *);
 
 /*
  * Function: osa_adb_create_policy
--- a/src/plugins/kdb/db2/pol_xdr.c
+++ b/src/plugins/kdb/db2/pol_xdr.c
@@ -1,6 +1,6 @@
 #include <sys/types.h>
 #include <krb5.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 #include <kdb.h>
 #include <kadm5/admin_xdr.h>
 #include "policy_db.h"
--- a/src/plugins/kdb/db2/policy_db.h
+++ b/src/plugins/kdb/db2/policy_db.h
@@ -28,8 +28,8 @@
 
    A better fix might be for db.h to include netinet/in.h if that's
    where we find u_int32_t.  */
-#include <gssrpc/types.h>
-#include <gssrpc/xdr.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
 #include <db.h>
 #include "adb_err.h"
 #include <com_err.h>
--- a/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.c
+++ b/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.c
@@ -3,6 +3,10 @@
 #include "princ_xdr.h"
 #include <kadm5/admin.h>
 
+/* Solaris Kerberos: symbols available from libkadm5srv_mit*/
+extern void	xdralloc_create(XDR *, enum xdr_op);
+extern caddr_t	xdralloc_getdata(XDR *);
+
 bool_t
 ldap_xdr_krb5_ui_2(XDR *xdrs, krb5_ui_2 *objp)
 {
--- a/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.h
+++ b/src/plugins/kdb/ldap/libkdb_ldap/princ_xdr.h
@@ -4,7 +4,7 @@
 #include <sys/types.h>
 #include <krb5.h>
 #include <kdb.h>
-#include <gssrpc/rpc.h>
+#include <rpc/rpc.h>
 
 #ifdef HAVE_MEMORY_H
 #include <memory.h>
--- a/src/slave/kpropd.c
+++ b/src/slave/kpropd.c
@@ -611,13 +611,14 @@ full_resync(CLIENT *clnt)
 
     memset(&clnt_res, 0, sizeof(clnt_res));
 
-    status = clnt_call(clnt, IPROP_FULL_RESYNC_EXT, (xdrproc_t)xdr_u_int32,
-                       &vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
-                       &clnt_res, full_resync_timeout);
+    status = clnt_call(clnt, IPROP_FULL_RESYNC_EXT, (xdrproc_t)xdr_u_int,
+                       (caddr_t)&vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
+                       (caddr_t)&clnt_res, full_resync_timeout);
     if (status == RPC_PROCUNAVAIL) {
         status = clnt_call(clnt, IPROP_FULL_RESYNC, (xdrproc_t)xdr_void,
-                           &vers, (xdrproc_t)xdr_kdb_fullresync_result_t,
-                           &clnt_res, full_resync_timeout);
+                           (caddr_t)&vers,
+			   (xdrproc_t)xdr_kdb_fullresync_result_t,
+                           (caddr_t)&clnt_res, full_resync_timeout);
     }
 
     return (status == RPC_SUCCESS) ? &clnt_res : NULL;
--- a/src/tests/misc/Makefile.in
+++ b/src/tests/misc/Makefile.in
@@ -12,18 +12,16 @@ SRCS=\
 	$(srcdir)/test_cxx_krb5.cpp \
 	$(srcdir)/test_cxx_k5int.cpp \
 	$(srcdir)/test_cxx_gss.cpp \
-	$(srcdir)/test_cxx_rpc.cpp \
 	$(srcdir)/test_cxx_kadm5.cpp
 
 all: test_getpw test_chpw_message
 
-check: test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_rpc test_cxx_k5int test_cxx_kadm5
+check: test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_kadm5
 	$(RUN_TEST) ./test_getpw
 	$(RUN_TEST) ./test_chpw_message
 	$(RUN_TEST) ./test_cxx_krb5
 	$(RUN_TEST) ./test_cxx_k5int
 	$(RUN_TEST) ./test_cxx_gss
-	$(RUN_TEST) ./test_cxx_rpc
 	$(RUN_TEST) ./test_cxx_kadm5
 
 test_getpw: $(OUTPRE)test_getpw.$(OBJEXT) $(SUPPORT_DEPLIB)
@@ -41,18 +39,15 @@ test_cxx_k5int: $(OUTPRE)test_cxx_k5int.$(OBJEXT) $(KRB5_DEPLIB)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_k5int $(OUTPRE)test_cxx_k5int.$(OBJEXT) $(KRB5_BASE_LIBS) $(LIBS)
 test_cxx_gss: $(OUTPRE)test_cxx_gss.$(OBJEXT)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_gss $(OUTPRE)test_cxx_gss.$(OBJEXT) $(LIBS)
-test_cxx_rpc: $(OUTPRE)test_cxx_rpc.$(OBJEXT) $(GSSRPC_DEPLIBS)
-	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_rpc $(OUTPRE)test_cxx_rpc.$(OBJEXT) $(GSSRPC_LIBS) $(KRB5_BASE_LIBS) $(LIBS)
 test_cxx_kadm5: $(OUTPRE)test_cxx_kadm5.$(OBJEXT) $(KADMCLNT_DEPLIBS)
 	$(CXX_LINK) $(ALL_CXXFLAGS) -o test_cxx_kadm5 $(OUTPRE)test_cxx_kadm5.$(OBJEXT) $(KADMCLNT_LIBS) $(KRB5_BASE_LIBS) $(LIBS)
 
 test_cxx_krb5.$(OBJEXT): test_cxx_krb5.cpp
 test_cxx_gss.$(OBJEXT): test_cxx_gss.cpp
-test_cxx_rpc.$(OBJEXT): test_cxx_rpc.cpp
 test_cxx_kadm5.$(OBJEXT): test_cxx_kadm5.cpp
 
 install:
 
 clean:
-	$(RM) test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_rpc test_cxx_kadm5 *.o
+	$(RM) test_getpw test_chpw_message test_cxx_krb5 test_cxx_gss test_cxx_k5int test_cxx_kadm5 *.o
 
--- a/src/tests/t_ccache.py
+++ b/src/tests/t_ccache.py
@@ -47,7 +47,7 @@ realm.kinit(realm.user_princ, password('user'))
 realm.run([klist, '-s'])
 realm.kinit(realm.user_princ, password('user'), ['-l', '-1s'])
 realm.run([klist, '-s'], expected_code=1)
-realm.kinit(realm.user_princ, password('user'), ['-S', 'kadmin/admin'])
+realm.kinit(realm.user_princ, password('user'), ['-S', 'kadmin/changepw'])
 realm.run([klist, '-s'])
 realm.run([kdestroy])
 realm.run([klist, '-s'], expected_code=1)
--- a/src/tests/t_iprop.py
+++ b/src/tests/t_iprop.py
@@ -5,6 +5,14 @@ import re
 
 from k5test import *
 
+#
+# Solaris Kerberos
+#
+# We cannot run register iprop rpc program twice on one host and
+# hence we are not able to test hierarchical iprop on a single host.
+# This test has been modified to test 'flat' iprop only.
+#
+
 # Read lines from kpropd output until we are synchronized.  Error if
 # full_expected is true and we didn't see a full propagation or vice
 # versa.
@@ -119,42 +127,12 @@ conf = {'realms': {'$realm': {'iprop_enable': 'true',
 conf_slave1 = {'realms': {'$realm': {'iprop_slave_poll': '600',
                                      'iprop_logfile': '$testdir/ulog.slave1'}},
                'dbmodules': {'db': {'database_name': '$testdir/db.slave1'}}}
-conf_slave1m = {'realms': {'$realm': {'iprop_logfile': '$testdir/ulog.slave1',
-                                      'iprop_port': '$port8'}},
-               'dbmodules': {'db': {'database_name': '$testdir/db.slave1'}}}
-conf_slave2 = {'realms': {'$realm': {'iprop_slave_poll': '600',
-                                     'iprop_logfile': '$testdir/ulog.slave2',
-                                     'iprop_port': '$port8'}},
-               'dbmodules': {'db': {'database_name': '$testdir/db.slave2'}}}
 
-conf_foo = {'libdefaults': {'default_realm': 'FOO'},
-            'domain_realm': {hostname: 'FOO'}}
+conf_foo = {'libdefaults': {'default_realm': 'FOO'}
+            }
 
 realm = K5Realm(kdc_conf=conf, create_user=False, start_kadmind=True)
 slave1 = realm.special_env('slave1', True, kdc_conf=conf_slave1)
-slave1m = realm.special_env('slave1m', True, krb5_conf=conf_foo,
-                            kdc_conf=conf_slave1m)
-slave2 = realm.special_env('slave2', True, kdc_conf=conf_slave2)
-
-# A default_realm and domain_realm that do not match the KDC's realm.
-# The FOO realm iprop_logfile setting is needed to run kproplog during
-# a slave3 test, since kproplog has no realm option.
-conf_slave3 = {'realms': {'$realm': {'iprop_slave_poll': '600',
-                                     'iprop_logfile': '$testdir/ulog.slave3',
-                                     'iprop_port': '$port8'},
-                          'FOO': {'iprop_logfile': '$testdir/ulog.slave3'}},
-               'dbmodules': {'db': {'database_name': '$testdir/db.slave3'}}}
-slave3 = realm.special_env('slave3', True, krb5_conf=conf_foo,
-                           kdc_conf=conf_slave3)
-
-# A default realm and a domain realm map that differ.
-krb5_conf_slave4 = {'domain_realm': {hostname: 'FOO'}}
-conf_slave4 = {'realms': {'$realm': {'iprop_slave_poll': '600',
-                                     'iprop_logfile': '$testdir/ulog.slave4',
-                                     'iprop_port': '$port8'}},
-               'dbmodules': {'db': {'database_name': '$testdir/db.slave4'}}}
-slave4 = realm.special_env('slave4', True, krb5_conf=krb5_conf_slave4,
-                            kdc_conf=conf_slave4)
 
 # Define some principal names.  pr3 is long enough to cause internal
 # reallocs, but not long enough to grow the basic ulog entry size.
@@ -183,9 +161,6 @@ realm.extract_keytab(kiprop_princ, realm.keytab)
 dumpfile = os.path.join(realm.testdir, 'dump')
 realm.run([kdb5_util, 'dump', dumpfile])
 realm.run([kdb5_util, 'load', dumpfile], slave1)
-realm.run([kdb5_util, 'load', dumpfile], slave2)
-realm.run([kdb5_util, '-r', realm.realm, 'load', dumpfile], slave3)
-realm.run([kdb5_util, 'load', dumpfile], slave4)
 
 # Reinitialize the master ulog so we know exactly what to expect in
 # it.
@@ -217,27 +192,6 @@ check_ulog(2, 6, 7, [None, pr2], slave1)
 realm.run([kadminl, 'getprinc', pr2], env=slave1,
           expected_msg='Attributes: DISALLOW_ALL_TIX')
 
-# Start kadmind -proponly for slave1.  (Use the slave1m environment
-# which defines iprop_port to $port8.)
-slave1_out_dump_path = os.path.join(realm.testdir, 'dump.slave1.out')
-slave2_in_dump_path = os.path.join(realm.testdir, 'dump.slave2.in')
-slave2_kprop_port = str(realm.portbase + 9)
-realm.start_server([kadmind, '-r', realm.realm, '-nofork', '-proponly', '-W',
-                    '-p', kdb5_util, '-K', kprop, '-k', slave2_kprop_port,
-                    '-F', slave1_out_dump_path], 'starting...', slave1m)
-
-# Test similar default_realm and domain_realm map settings with -r realm.
-slave3_in_dump_path = os.path.join(realm.testdir, 'dump.slave3.in')
-kpropd3 = realm.start_server([kpropd, '-d', '-D', '-r', realm.realm, '-P',
-                              slave2_kprop_port, '-f', slave3_in_dump_path,
-                              '-p', kdb5_util, '-a', acl_file, '-A', hostname],
-                             'ready', slave3)
-wait_for_prop(kpropd3, True, 1, 7)
-out = realm.run([kadminl, '-r', realm.realm, 'listprincs'], env=slave3)
-if pr1 not in out or pr2 not in out or pr3 not in out:
-    fail('slave3 does not have all principals from slave1')
-check_ulog(1, 7, 7, [None], env=slave3)
-
 # Test an incremental propagation for the kpropd -r case.
 realm.run([kadminl, 'modprinc', '-maxlife', '20 minutes', pr1])
 check_ulog(8, 1, 8, [None, pr1, pr3, pr2, pr2, pr2, pr2, pr1])
@@ -246,36 +200,6 @@ wait_for_prop(kpropd1, False, 7, 8)
 check_ulog(3, 6, 8, [None, pr2, pr1], slave1)
 realm.run([kadminl, 'getprinc', pr1], env=slave1,
           expected_msg='Maximum ticket life: 0 days 00:20:00')
-kpropd3.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd3, False, 7, 8)
-check_ulog(2, 7, 8, [None, pr1], slave3)
-realm.run([kadminl, '-r', realm.realm, 'getprinc', pr1], env=slave3,
-          expected_msg='Maximum ticket life: 0 days 00:20:00')
-stop_daemon(kpropd3)
-
-# Test dissimilar default_realm and domain_realm map settings (no -r realm).
-slave4_in_dump_path = os.path.join(realm.testdir, 'dump.slave4.in')
-kpropd4 = realm.start_server([kpropd, '-d', '-D', '-P', slave2_kprop_port,
-                              '-f', slave4_in_dump_path, '-p', kdb5_util,
-                              '-a', acl_file, '-A', hostname], 'ready', slave4)
-wait_for_prop(kpropd4, True, 1, 8)
-out = realm.run([kadminl, 'listprincs'], env=slave4)
-if pr1 not in out or pr2 not in out or pr3 not in out:
-    fail('slave4 does not have all principals from slave1')
-stop_daemon(kpropd4)
-
-# Start kpropd for slave2.  The -A option isn't needed since we're
-# talking to the same host as master (we specify it anyway to exercise
-# the code), but slave2 defines iprop_port to $port8 so it will talk
-# to slave1.  Get a full dump from slave1.
-kpropd2 = realm.start_server([kpropd, '-d', '-D', '-P', slave2_kprop_port,
-                              '-f', slave2_in_dump_path, '-p', kdb5_util,
-                              '-a', acl_file, '-A', hostname], 'ready', slave2)
-wait_for_prop(kpropd2, True, 1, 8)
-check_ulog(2, 7, 8, [None, pr1], slave2)
-out = realm.run([kadminl, 'listprincs'], env=slave1)
-if pr1 not in out or pr2 not in out or pr3 not in out:
-    fail('slave2 does not have all principals from slave1')
 
 # Make another change and check that it propagates incrementally to
 # both slaves.
@@ -286,11 +210,6 @@ wait_for_prop(kpropd1, False, 8, 9)
 check_ulog(4, 6, 9, [None, pr2, pr1, pr1], slave1)
 realm.run([kadminl, 'getprinc', pr1], env=slave1,
           expected_msg='Maximum renewable life: 0 days 22:00:00\n')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 8, 9)
-check_ulog(3, 7, 9, [None, pr1, pr1], slave2)
-realm.run([kadminl, 'getprinc', pr1], env=slave2,
-          expected_msg='Maximum renewable life: 0 days 22:00:00\n')
 
 # Reset the ulog on slave1 to force a full resync from master.  The
 # resync will use the old dump file and then propagate changes.
@@ -301,9 +220,6 @@ check_ulog(1, 1, 1, [None], slave1)
 kpropd1.send_signal(signal.SIGUSR1)
 wait_for_prop(kpropd1, True, 1, 9)
 check_ulog(4, 6, 9, [None, pr2, pr1, pr1], slave1)
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 9, 9)
-check_ulog(3, 7, 9, [None, pr1, pr1], slave2)
 
 # Make another change and check that it propagates incrementally to
 # both slaves.
@@ -313,10 +229,6 @@ kpropd1.send_signal(signal.SIGUSR1)
 wait_for_prop(kpropd1, False, 9, 10)
 check_ulog(5, 6, 10, [None, pr2, pr1, pr1, pr2], slave1)
 realm.run([kadminl, 'getprinc', pr2], env=slave1, expected_msg='Attributes:\n')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 9, 10)
-check_ulog(4, 7, 10, [None, pr1, pr1, pr2], slave2)
-realm.run([kadminl, 'getprinc', pr2], env=slave2, expected_msg='Attributes:\n')
 
 # Create a policy and check that it propagates via full resync.
 realm.run([kadminl, 'addpol', '-minclasses', '2', 'testpol'])
@@ -326,11 +238,6 @@ wait_for_prop(kpropd1, True, 10, 1)
 check_ulog(1, 1, 1, [None], slave1)
 realm.run([kadminl, 'getpol', 'testpol'], env=slave1,
           expected_msg='Minimum number of password character classes: 2')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, True, 10, 1)
-check_ulog(1, 1, 1, [None], slave2)
-realm.run([kadminl, 'getpol', 'testpol'], env=slave2,
-          expected_msg='Minimum number of password character classes: 2')
 
 # Modify the policy and test that it also propagates via full resync.
 realm.run([kadminl, 'modpol', '-minlength', '17', 'testpol'])
@@ -340,11 +247,6 @@ wait_for_prop(kpropd1, True, 1, 1)
 check_ulog(1, 1, 1, [None], slave1)
 realm.run([kadminl, 'getpol', 'testpol'], env=slave1,
           expected_msg='Minimum password length: 17')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, True, 1, 1)
-check_ulog(1, 1, 1, [None], slave2)
-realm.run([kadminl, 'getpol', 'testpol'], env=slave2,
-          expected_msg='Minimum password length: 17')
 
 # Delete the policy and test that it propagates via full resync.
 realm.run([kadminl, 'delpol', 'testpol'])
@@ -354,11 +256,6 @@ wait_for_prop(kpropd1, True, 1, 1)
 check_ulog(1, 1, 1, [None], slave1)
 realm.run([kadminl, 'getpol', 'testpol'], env=slave1, expected_code=1,
           expected_msg='Policy does not exist')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, True, 1, 1)
-check_ulog(1, 1, 1, [None], slave2)
-realm.run([kadminl, 'getpol', 'testpol'], env=slave2, expected_code=1,
-          expected_msg='Policy does not exist')
 
 # Modify a principal on the master and test that it propagates incrementally.
 realm.run([kadminl, 'modprinc', '-maxlife', '10 minutes', pr1])
@@ -368,11 +265,6 @@ wait_for_prop(kpropd1, False, 1, 2)
 check_ulog(2, 1, 2, [None, pr1], slave1)
 realm.run([kadminl, 'getprinc', pr1], env=slave1,
           expected_msg='Maximum ticket life: 0 days 00:10:00')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 1, 2)
-check_ulog(2, 1, 2, [None, pr1], slave2)
-realm.run([kadminl, 'getprinc', pr1], env=slave2,
-          expected_msg='Maximum ticket life: 0 days 00:10:00')
 
 # Delete a principal and test that it propagates incrementally.
 realm.run([kadminl, 'delprinc', pr3])
@@ -382,11 +274,6 @@ wait_for_prop(kpropd1, False, 2, 3)
 check_ulog(3, 1, 3, [None, pr1, pr3], slave1)
 realm.run([kadminl, 'getprinc', pr3], env=slave1, expected_code=1,
           expected_msg='Principal does not exist')
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 2, 3)
-check_ulog(3, 1, 3, [None, pr1, pr3], slave2)
-realm.run([kadminl, 'getprinc', pr3], env=slave2, expected_code=1,
-          expected_msg='Principal does not exist')
 
 # Rename a principal and test that it propagates incrementally.
 renpr = "quacked@" + realm.realm
@@ -398,12 +285,6 @@ check_ulog(6, 1, 6, [None, pr1, pr3, renpr, pr1, renpr], slave1)
 realm.run([kadminl, 'getprinc', pr1], env=slave1, expected_code=1,
           expected_msg='Principal does not exist')
 realm.run([kadminl, 'getprinc', renpr], env=slave1)
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, False, 3, 6)
-check_ulog(6, 1, 6, [None, pr1, pr3, renpr, pr1, renpr], slave2)
-realm.run([kadminl, 'getprinc', pr1], env=slave2, expected_code=1,
-          expected_msg='Principal does not exist')
-realm.run([kadminl, 'getprinc', renpr], env=slave2)
 
 pr1 = renpr
 
@@ -413,13 +294,9 @@ check_ulog(1, 1, 1, [None])
 kpropd1.send_signal(signal.SIGUSR1)
 wait_for_prop(kpropd1, True, 6, 1)
 check_ulog(1, 1, 1, [None], slave1)
-kpropd2.send_signal(signal.SIGUSR1)
-wait_for_prop(kpropd2, True, 6, 1)
-check_ulog(1, 1, 1, [None], slave2)
 
 # Stop the kprop daemons so we can test kpropd -t.
 stop_daemon(kpropd1)
-stop_daemon(kpropd2)
 
 # Test the case where no updates are needed.
 out = realm.run_kpropd_once(slave1, ['-d'])
--- a/src/tests/t_kadmin_acl.py
+++ b/src/tests/t_kadmin_acl.py
@@ -10,7 +10,7 @@ def make_client(name):
     ccache = os.path.join(realm.testdir,
                           'kadmin_ccache_' + name.replace('/', '_'))
     realm.kinit(name, password(name),
-                flags=['-S', 'kadmin/admin', '-c', ccache])
+                flags=['-S', 'kadmin/' + hostname, '-c', ccache])
     return ccache
 
 def kadmin_as(client, query, **kwargs):
@@ -298,9 +298,9 @@ os.remove(realm.keytab)
 
 # Verify that self-service key changes require an initial ticket.
 realm.run([kadminl, 'cpw', '-pw', password('none'), 'none'])
-realm.run([kadminl, 'modprinc', '+allow_tgs_req', 'kadmin/admin'])
+realm.run([kadminl, 'modprinc', '+allow_tgs_req', 'kadmin/' + hostname])
 realm.kinit('none', password('none'))
-realm.run([kvno, 'kadmin/admin'])
+realm.run([kvno, 'kadmin/' + hostname])
 msg = 'Operation requires initial ticket'
 realm.run([kadmin, '-c', realm.ccache, 'cpw', '-pw', 'newpw', 'none'],
           expected_code=1, expected_msg=msg)
--- a/src/util/k5test.py
+++ b/src/util/k5test.py
@@ -1051,7 +1051,7 @@ class K5Realm(object):
             princname = self.admin_princ
             pw = password('admin')
         return self.kinit(princname, pw,
-                          flags=['-S', 'kadmin/admin',
+                          flags=['-S', 'kadmin/' + hostname,
                                  '-c', self.kadmin_ccache] + flags)
 
     def run_kadmin(self, args, **keywords):
